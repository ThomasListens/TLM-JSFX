desc:Professional Binaural 3D Panner
author: Enhanced Version
version: 2.0
changelog: Improved HRTF modeling, smoother transitions, better spatialization
about:
  ## Professional Binaural 3D Panner
  
  Advanced binaural panning with realistic HRTF modeling:
  - Accurate ITD/ILD modeling
  - Smooth distance-based filtering
  - Natural movement interpolation
  - Head shadow simulation
  - Early reflection modeling

slider1:pattern=0<0,5,1{Static,Circular CW,Circular CCW,Random Walk,Figure-8,Spiral}>Movement Pattern
slider2:speed=0.5<0.01,10,0.01>Movement Speed (Hz)
slider3:radius=1.5<0.1,5,0.01>Movement Radius (m)
slider4:azimuth_deg=0<-180,180,1>Azimuth (degrees)
slider5:elevation_deg=0<-90,90,1>Elevation (degrees)
slider6:distance=1.5<0.3,10,0.01>Distance (m)
slider7:room_size=0.3<0,1,0.01>Room Size
slider8:smoothing=0.95<0.8,0.999,0.001>Movement Smoothing

options:want_all_kb

@init
  // Constants
  pi = $pi;
  twopi = 2 * pi;
  halfpi = pi * 0.5;
  deg2rad = pi / 180;
  
  // Head parameters (in meters)
  head_radius = 0.0875; // Average head radius
  speed_of_sound = 343.0; // m/s at room temperature
  
  // Movement variables
  movement_angle = 0;
  target_x = target_y = target_z = 0;
  smooth_x = smooth_y = smooth_z = 0;
  random_timer = 0;
  
  // HRTF delay line setup
  max_delay_ms = 2.0; // Maximum ITD + room delay
  delay_samples = ceil(srate * max_delay_ms / 1000);
  delay_buffer_l = 0;
  delay_buffer_r = delay_samples;
  delay_write_pos = 0;
  
  // Filter states (2nd order filters for each ear)
  // Low shelf
  ls_l_x1 = ls_l_x2 = ls_l_y1 = ls_l_y2 = 0;
  ls_r_x1 = ls_r_x2 = ls_r_y1 = ls_r_y2 = 0;
  
  // High shelf  
  hs_l_x1 = hs_l_x2 = hs_l_y1 = hs_l_y2 = 0;
  hs_r_x1 = hs_r_x2 = hs_r_y1 = hs_r_y2 = 0;
  
  // Notch filter for pinna effect
  notch_l_x1 = notch_l_x2 = notch_l_y1 = notch_l_y2 = 0;
  notch_r_x1 = notch_r_x2 = notch_r_y1 = notch_r_y2 = 0;
  
  // Early reflection taps
  er_delay1 = ceil(0.005 * srate); // 5ms
  er_delay2 = ceil(0.011 * srate); // 11ms
  er_delay3 = ceil(0.017 * srate); // 17ms
  
  // Crossfeed for improved externalization
  crossfeed_delay = ceil(0.0003 * srate); // 0.3ms
  crossfeed_gain = 0.15;
  
  // LFO for subtle movement variation
  lfo_phase = 0;
  lfo_rate = 0.1; // Hz

@slider
  // Convert degrees to radians for internal use
  azimuth_rad = azimuth_deg * deg2rad;
  elevation_rad = elevation_deg * deg2rad;
  
  // Update movement parameters
  movement_rate = twopi * speed / srate;
  
  // Clamp parameters to safe ranges
  distance = max(0.3, min(10, distance));
  radius = max(0.1, min(5, radius));
  smoothing = max(0.8, min(0.999, smoothing));

@block
  // Update random movement targets
  pattern == 3 ? (
    random_timer += samplesblock;
    random_timer > srate * 0.3 ? ( // New target every 0.3s
      // Random walk with momentum
      target_x += (rand() - 0.5) * radius * 0.5;
      target_y += (rand() - 0.5) * radius * 0.5;
      target_z += (rand() - 0.5) * radius * 0.3;
      
      // Keep within bounds
      max_dist = radius * 1.5;
      current_dist = sqrt(target_x^2 + target_y^2 + target_z^2);
      current_dist > max_dist ? (
        scale = max_dist / current_dist;
        target_x *= scale;
        target_y *= scale;
        target_z *= scale;
      );
      
      random_timer = 0;
    );
  );

@sample
  // Update LFO for micro-movements
  lfo_phase += lfo_rate * twopi / srate;
  lfo_phase >= twopi ? lfo_phase -= twopi;
  lfo_value = sin(lfo_phase) * 0.05; // Subtle variation
  
  // Calculate position based on pattern
  pattern == 0 ? ( // Static
    target_x = distance * cos(azimuth_rad) * cos(elevation_rad);
    target_y = distance * sin(azimuth_rad) * cos(elevation_rad);
    target_z = distance * sin(elevation_rad);
  ) : pattern == 1 ? ( // Circular CW
    target_x = radius * cos(movement_angle) * cos(elevation_rad);
    target_y = radius * sin(movement_angle) * cos(elevation_rad);
    target_z = distance * sin(elevation_rad);
    movement_angle += movement_rate;
  ) : pattern == 2 ? ( // Circular CCW
    target_x = radius * cos(-movement_angle) * cos(elevation_rad);
    target_y = radius * sin(-movement_angle) * cos(elevation_rad);
    target_z = distance * sin(elevation_rad);
    movement_angle += movement_rate;
  ) : pattern == 4 ? ( // Figure-8
    target_x = radius * sin(movement_angle) * cos(elevation_rad);
    target_y = radius * sin(2 * movement_angle) * 0.5 * cos(elevation_rad);
    target_z = distance * sin(elevation_rad) + radius * sin(3 * movement_angle) * 0.2;
    movement_angle += movement_rate;
  ) : pattern == 5 ? ( // Spiral
    spiral_r = radius * (0.2 + 0.8 * abs(sin(movement_angle * 0.1)));
    target_x = spiral_r * cos(movement_angle) * cos(elevation_rad);
    target_y = spiral_r * sin(movement_angle) * cos(elevation_rad);
    target_z = distance * sin(elevation_rad) + radius * sin(movement_angle * 0.2) * 0.3;
    movement_angle += movement_rate;
  );
  
  // Apply smoothing with variable rate based on distance
  smooth_rate = smoothing - (1 - smoothing) * min(1, distance / 5);
  smooth_x = smooth_x * smooth_rate + target_x * (1 - smooth_rate);
  smooth_y = smooth_y * smooth_rate + target_y * (1 - smooth_rate);
  smooth_z = smooth_z * smooth_rate + target_z * (1 - smooth_rate);
  
  // Add LFO micro-movement
  pos_x = smooth_x + lfo_value * 0.1;
  pos_y = smooth_y + lfo_value * 0.15;
  pos_z = smooth_z;
  
  // Calculate spherical coordinates
  dist_3d = sqrt(pos_x^2 + pos_y^2 + pos_z^2);
  dist_3d = max(0.3, dist_3d); // Minimum distance
  
  azimuth = atan2(pos_y, pos_x);
  elevation = atan2(pos_z, sqrt(pos_x^2 + pos_y^2));
  
  // Calculate ITD using Woodworth & Schlosberg formula
  // ITD = (head_radius / speed_of_sound) * (azimuth + sin(azimuth))
  itd_seconds = (head_radius / speed_of_sound) * (abs(azimuth) + sin(abs(azimuth)));
  itd_samples = itd_seconds * srate;
  
  // Calculate ILD (Interaural Level Difference)
  // Using frequency-dependent head shadow model
  ild_db = 20 * sin(abs(azimuth)) / (1 + dist_3d * 0.5);
  
  // Distance attenuation with air absorption
  dist_atten = 1 / (1 + dist_3d * 0.15);
  air_absorption = exp(-0.0002 * dist_3d); // High frequency absorption
  
  // Calculate filter parameters based on HRTF data
  // Low shelf - head shadow effect
  ls_freq = 200 + 500 * (1 - cos(abs(azimuth)));
  ls_gain_db = -ild_db * 0.5;
  
  // High shelf - distance and elevation cues
  hs_freq = 2000 + 3000 * cos(elevation);
  hs_gain_db = -3 * dist_3d - 6 * sin(elevation);
  
  // Notch filter - pinna effect (elevation cue)
  notch_freq = 6000 + 2000 * sin(elevation);
  notch_q = 2 + abs(elevation) * 2;
  
  // Calculate filter coefficients
  // Low shelf
  ls_w = twopi * ls_freq / srate;
  ls_s = sin(ls_w);
  ls_c = cos(ls_w);
  ls_A = pow(10, ls_gain_db / 40);
  ls_alpha = ls_s / 2 * sqrt((ls_A + 1/ls_A) * (1/0.7 - 1) + 2);
  
  ls_b0 = ls_A * ((ls_A + 1) - (ls_A - 1) * ls_c + 2 * sqrt(ls_A) * ls_alpha);
  ls_b1 = 2 * ls_A * ((ls_A - 1) - (ls_A + 1) * ls_c);
  ls_b2 = ls_A * ((ls_A + 1) - (ls_A - 1) * ls_c - 2 * sqrt(ls_A) * ls_alpha);
  ls_a0 = (ls_A + 1) + (ls_A - 1) * ls_c + 2 * sqrt(ls_A) * ls_alpha;
  ls_a1 = -2 * ((ls_A - 1) + (ls_A + 1) * ls_c);
  ls_a2 = (ls_A + 1) + (ls_A - 1) * ls_c - 2 * sqrt(ls_A) * ls_alpha;
  // Normalize coefficients
  ls_norm = 1 / ls_a0;
  ls_b0 *= ls_norm; ls_b1 *= ls_norm; ls_b2 *= ls_norm;
  ls_a1 *= ls_norm; ls_a2 *= ls_norm;
  
  // High shelf
  hs_w = twopi * hs_freq / srate;
  hs_s = sin(hs_w);
  hs_c = cos(hs_w);
  hs_A = pow(10, hs_gain_db / 40);
  hs_alpha = hs_s / 2 * sqrt((hs_A + 1/hs_A) * (1/0.7 - 1) + 2);
  
  hs_b0 = hs_A * ((hs_A + 1) + (hs_A - 1) * hs_c + 2 * sqrt(hs_A) * hs_alpha);
  hs_b1 = -2 * hs_A * ((hs_A - 1) + (hs_A + 1) * hs_c);
  hs_b2 = hs_A * ((hs_A + 1) + (hs_A - 1) * hs_c - 2 * sqrt(hs_A) * hs_alpha);
  hs_a0 = (hs_A + 1) - (hs_A - 1) * hs_c + 2 * sqrt(hs_A) * hs_alpha;
  hs_a1 = 2 * ((hs_A - 1) - (hs_A + 1) * hs_c);
  hs_a2 = (hs_A + 1) - (hs_A - 1) * hs_c - 2 * sqrt(hs_A) * hs_alpha;
  
  hs_norm = 1 / hs_a0;
  hs_b0 *= hs_norm; hs_b1 *= hs_norm; hs_b2 *= hs_norm;
  hs_a1 *= hs_norm; hs_a2 *= hs_norm;
  
  // Notch filter (for pinna cue)
  notch_w = twopi * notch_freq / srate;
  notch_alpha = sin(notch_w) / (2 * notch_q);
  notch_c = cos(notch_w);
  
  notch_b0 = 1;
  notch_b1 = -2 * notch_c;
  notch_b2 = 1;
  notch_a0 = 1 + notch_alpha;
  notch_a1 = -2 * notch_c;
  notch_a2 = 1 - notch_alpha;
  
  notch_norm = 1 / notch_a0;
  notch_b0 *= notch_norm; notch_b1 *= notch_norm; notch_b2 *= notch_norm;
  notch_a1 *= notch_norm; notch_a2 *= notch_norm;
  
  // Get input (mono sum for processing)
  input = (spl0 + spl1) * 0.5;
  
  // Write to delay buffer
  delay_buffer_l[delay_write_pos] = input;
  delay_buffer_r[delay_write_pos] = input;
  
  // Calculate delay positions for each ear
  azimuth > 0 ? ( // Sound on right
    left_delay = itd_samples;
    right_delay = 0;
    left_gain = dist_atten * pow(10, -ild_db / 20);
    right_gain = dist_atten;
  ) : ( // Sound on left
    left_delay = 0;
    right_delay = itd_samples;
    left_gain = dist_atten;
    right_gain = dist_atten * pow(10, -ild_db / 20);
  );
  
  // Apply elevation gain adjustment
  elevation_factor = cos(elevation);
  left_gain *= elevation_factor;
  right_gain *= elevation_factor;
  
  // Read delayed samples with linear interpolation
  left_pos = delay_write_pos - left_delay;
  left_pos < 0 ? left_pos += delay_samples;
  left_idx = floor(left_pos);
  left_frac = left_pos - left_idx;
  left_idx2 = left_idx + 1;
  left_idx2 >= delay_samples ? left_idx2 = 0;
  
  left_sample = delay_buffer_l[left_idx] * (1 - left_frac) + 
                delay_buffer_l[left_idx2] * left_frac;
  
  right_pos = delay_write_pos - right_delay;
  right_pos < 0 ? right_pos += delay_samples;
  right_idx = floor(right_pos);
  right_frac = right_pos - right_idx;
  right_idx2 = right_idx + 1;
  right_idx2 >= delay_samples ? right_idx2 = 0;
  
  right_sample = delay_buffer_r[right_idx] * (1 - right_frac) + 
                 delay_buffer_r[right_idx2] * right_frac;
  
  // Apply HRTF filtering
  // Left ear - Low shelf
  ls_l_out = ls_b0 * left_sample + ls_b1 * ls_l_x1 + ls_b2 * ls_l_x2 - 
             ls_a1 * ls_l_y1 - ls_a2 * ls_l_y2;
  ls_l_x2 = ls_l_x1; ls_l_x1 = left_sample;
  ls_l_y2 = ls_l_y1; ls_l_y1 = ls_l_out;
  
  // Left ear - High shelf
  hs_l_out = hs_b0 * ls_l_out + hs_b1 * hs_l_x1 + hs_b2 * hs_l_x2 - 
             hs_a1 * hs_l_y1 - hs_a2 * hs_l_y2;
  hs_l_x2 = hs_l_x1; hs_l_x1 = ls_l_out;
  hs_l_y2 = hs_l_y1; hs_l_y1 = hs_l_out;
  
  // Left ear - Notch (only if elevation is significant)
  abs(elevation) > 0.1 ? (
    notch_l_out = notch_b0 * hs_l_out + notch_b1 * notch_l_x1 + notch_b2 * notch_l_x2 - 
                  notch_a1 * notch_l_y1 - notch_a2 * notch_l_y2;
    notch_l_x2 = notch_l_x1; notch_l_x1 = hs_l_out;
    notch_l_y2 = notch_l_y1; notch_l_y1 = notch_l_out;
    left_filtered = notch_l_out;
  ) : (
    left_filtered = hs_l_out;
  );
  
  // Right ear - same filtering chain
  ls_r_out = ls_b0 * right_sample + ls_b1 * ls_r_x1 + ls_b2 * ls_r_x2 - 
             ls_a1 * ls_r_y1 - ls_a2 * ls_r_y2;
  ls_r_x2 = ls_r_x1; ls_r_x1 = right_sample;
  ls_r_y2 = ls_r_y1; ls_r_y1 = ls_r_out;
  
  hs_r_out = hs_b0 * ls_r_out + hs_b1 * hs_r_x1 + hs_b2 * hs_r_x2 - 
             hs_a1 * hs_r_y1 - hs_a2 * hs_r_y2;
  hs_r_x2 = hs_r_x1; hs_r_x1 = ls_r_out;
  hs_r_y2 = hs_r_y1; hs_r_y1 = hs_r_out;
  
  abs(elevation) > 0.1 ? (
    notch_r_out = notch_b0 * hs_r_out + notch_b1 * notch_r_x1 + notch_b2 * notch_r_x2 - 
                  notch_a1 * notch_r_y1 - notch_a2 * notch_r_y2;
    notch_r_x2 = notch_r_x1; notch_r_x1 = hs_r_out;
    notch_r_y2 = notch_r_y1; notch_r_y1 = notch_r_out;
    right_filtered = notch_r_out;
  ) : (
    right_filtered = hs_r_out;
  );
  
  // Add early reflections for room simulation
  room_size > 0.01 ? (
    er_pos1 = delay_write_pos - er_delay1;
    er_pos1 < 0 ? er_pos1 += delay_samples;
    er_pos2 = delay_write_pos - er_delay2;
    er_pos2 < 0 ? er_pos2 += delay_samples;
    er_pos3 = delay_write_pos - er_delay3;
    er_pos3 < 0 ? er_pos3 += delay_samples;
    
    er_gain = room_size * 0.3;
    left_filtered += (delay_buffer_l[er_pos1] * 0.5 + 
                      delay_buffer_l[er_pos2] * 0.3 + 
                      delay_buffer_l[er_pos3] * 0.2) * er_gain;
    right_filtered += (delay_buffer_r[er_pos1] * 0.5 + 
                       delay_buffer_r[er_pos2] * 0.3 + 
                       delay_buffer_r[er_pos3] * 0.2) * er_gain;
  );
  
  // Add crossfeed for better externalization
  cf_pos = delay_write_pos - crossfeed_delay;
  cf_pos < 0 ? cf_pos += delay_samples;
  
  left_out = left_filtered * left_gain + 
             delay_buffer_r[cf_pos] * crossfeed_gain * right_gain;
  right_out = right_filtered * right_gain + 
              delay_buffer_l[cf_pos] * crossfeed_gain * left_gain;
  
  // Apply air absorption
  left_out *= air_absorption;
  right_out *= air_absorption;
  
  // Soft limiting to prevent clipping
  left_out = left_out / (1 + abs(left_out) * 0.25);
  right_out = right_out / (1 + abs(right_out) * 0.25);
  
  // Output
  spl0 = left_out;
  spl1 = right_out;
  
  // Update delay write position
  delay_write_pos += 1;
  delay_write_pos >= delay_samples ? delay_write_pos = 0;
  
  // Wrap movement angle
  movement_angle >= twopi ? movement_angle -= twopi;
