desc:Retro Codec Suite (TLM)
tags:n64 psx vadpcm adpcm nintendo playstation retro compression apple 1bit
version:8.3
author:Thomas

// HIDDEN SLIDERS
slider1:sample_rate_idx=3<0,4,1>-Sample Rate Index
slider2:bit_depth_idx=2<0,3,1>-Bit Depth Index  
slider3:drive=0<0,1,0.001>-Drive Amount
slider4:output_gain=0.8333<0,1,0.001>-Output Level
slider5:dry_wet_mix=1.0<0,1,0.001>-Mix
slider6:artifact_amount=0<0,1,0.001>-Artifact Amount
slider7:codec_type=0<0,4,1>-Codec Type
slider8:lofi_filter=0<0,1,1>-Lo-Fi Filter
slider9:aa_filter=0<0,1,1>-Anti-Aliasing Filter

@init

// Sample rate presets
sample_rates = 1000;
sample_rates[0] = 8000;
sample_rates[1] = 11025;
sample_rates[2] = 16000;
sample_rates[3] = 22050;
sample_rates[4] = 32000;
sample_rates[5] = 44100;

// Bit depth presets
bit_depths = 1100;
bit_depths[0] = 1;
bit_depths[1] = 2;
bit_depths[2] = 4;
bit_depths[3] = 6;
bit_depths[4] = 8;
bit_depths[5] = 12;
bit_depths[6] = 16;

// Default values
DEFAULT_SAMPLE_RATE = 0.833;
DEFAULT_BIT_DEPTH = 0.571;
DEFAULT_DRIVE = 0;
DEFAULT_OUTPUT = 0.8333;
DEFAULT_MIX = 1.0;
DEFAULT_ARTIFACTS = 0;
DEFAULT_CODEC = 0;
DEFAULT_LOFI = 0;
DEFAULT_AA = 0;

// GUI State
gui_sample_rate = DEFAULT_SAMPLE_RATE;
gui_bit_depth = DEFAULT_BIT_DEPTH;
gui_artifacts = DEFAULT_ARTIFACTS;
gui_drive = DEFAULT_DRIVE;
gui_output = DEFAULT_OUTPUT;
gui_mix = DEFAULT_MIX;
gui_codec = DEFAULT_CODEC;
gui_lofi = DEFAULT_LOFI;
gui_aa = DEFAULT_AA;

// Fine control state
fine_control_active = 0;
display_sr_val = 44100;
display_bit_val = 8;
sample_rate_limited = 0;

// Smoothing
smooth_drive = 0;
smooth_artifacts = 0;
smooth_mix = 1.0;
smooth_output = 0.8333;

// Colors
BG_COLOR = 0.08;
FG_COLOR = 0.9;
ACCENT_R = 0.3; ACCENT_G = 0.5; ACCENT_B = 0.9;
TRACK_COLOR = 0.15;
NOTCH_COLOR = 0.25;
FINE_COLOR_R = 1.0; FINE_COLOR_G = 0.6; FINE_COLOR_B = 0.0;
LIMIT_COLOR_R = 0.9; LIMIT_COLOR_G = 0.3; LIMIT_COLOR_B = 0.3;

// Layout
MARGIN = 25;
SLIDER_HEIGHT = 10;
SLIDER_WIDTH = 320;
DROPDOWN_HEIGHT = 32;
DROPDOWN_WIDTH = 280;

// DSP Memory allocation - INITIALIZE ALL TO ZERO
predictor_L = 0;
predictor_R = 1;
step_index_L = 2;
step_index_R = 3;
predictor_L2 = 4;
predictor_R2 = 5;
psx_s1_L = 6;
psx_s2_L = 7;
psx_s1_R = 8;
psx_s2_R = 9;
lpf_a0_L = 10;
lpf_a0_R = 13;
aa_lpf_L = 20;
aa_lpf_R = 21;
onebit_delta_L = 22;
onebit_delta_R = 23;
onebit_dc_L = 24;  // DC blocker state for 1-bit
onebit_dc_R = 25;

// Initialize all DSP memory to zero
memset(0, 0, 100);

// Tables memory allocation
vadpcm_table = 800;
ima_step_table = 900;
ima_index_table = 1000;
psx_filter = 1050;

// Mouse state
dropdown_open = 0;
dropdown_hover = -1;
mouse_was_down = 0;
dragging_slider = -1;
last_click_time = 0;
last_click_slider = -1;
DOUBLE_CLICK_TIME = 0.3;

// Playback state tracking for click prevention
playback_started = 0;
startup_fade_samples = 0;
STARTUP_FADE_LENGTH = 64;  // Samples to fade in on playback start

// Helper functions
function db_to_linear(db) ( exp(db * 0.11512925); );

function tanh_approx(x)
local(x2)
(
  x2 = x * x;
  x * (27 + x2) / (27 + 9 * x2);
);

// Musical scaling for artifacts
function scale_artifacts(linear_val)
(
  linear_val > 0 ? pow(linear_val, 2.5) * linear_val : 0;
);

// Check if sample rate is safe for 1-bit codec
function is_safe_for_onebit(sr_val)
(
  sr_val >= 0.833;
);

// Initialize authentic codec tables
function init_tables()
local(i)
(
  // N64 VADPCM predictor table
  vadpcm_table[0] = 0;        vadpcm_table[1] = 0;
  vadpcm_table[2] = -0.9375;  vadpcm_table[3] = 0;
  vadpcm_table[4] = 1.796875; vadpcm_table[5] = -0.8125;
  vadpcm_table[6] = 1.53125;  vadpcm_table[7] = -0.859375;
  vadpcm_table[8] = 1.90625;  vadpcm_table[9] = -0.9375;
  
  // IMA ADPCM step table (89 values)
  ima_step_table[0] = 7;     ima_step_table[1] = 8;
  ima_step_table[2] = 9;     ima_step_table[3] = 10;
  ima_step_table[4] = 11;    ima_step_table[5] = 12;
  ima_step_table[6] = 13;    ima_step_table[7] = 14;
  ima_step_table[8] = 16;    ima_step_table[9] = 17;
  ima_step_table[10] = 19;   ima_step_table[11] = 21;
  ima_step_table[12] = 23;   ima_step_table[13] = 25;
  ima_step_table[14] = 28;   ima_step_table[15] = 31;
  ima_step_table[16] = 34;   ima_step_table[17] = 37;
  ima_step_table[18] = 41;   ima_step_table[19] = 45;
  ima_step_table[20] = 50;   ima_step_table[21] = 55;
  ima_step_table[22] = 60;   ima_step_table[23] = 66;
  ima_step_table[24] = 73;   ima_step_table[25] = 80;
  ima_step_table[26] = 88;   ima_step_table[27] = 97;
  ima_step_table[28] = 107;  ima_step_table[29] = 118;
  ima_step_table[30] = 130;  ima_step_table[31] = 143;
  ima_step_table[32] = 157;  ima_step_table[33] = 173;
  ima_step_table[34] = 190;  ima_step_table[35] = 209;
  ima_step_table[36] = 230;  ima_step_table[37] = 253;
  ima_step_table[38] = 279;  ima_step_table[39] = 307;
  ima_step_table[40] = 337;  ima_step_table[41] = 371;
  ima_step_table[42] = 408;  ima_step_table[43] = 449;
  ima_step_table[44] = 494;  ima_step_table[45] = 544;
  ima_step_table[46] = 598;  ima_step_table[47] = 658;
  ima_step_table[48] = 724;  ima_step_table[49] = 796;
  ima_step_table[50] = 876;  ima_step_table[51] = 963;
  ima_step_table[52] = 1060; ima_step_table[53] = 1166;
  ima_step_table[54] = 1282; ima_step_table[55] = 1411;
  ima_step_table[56] = 1552; ima_step_table[57] = 1707;
  ima_step_table[58] = 1878; ima_step_table[59] = 2066;
  ima_step_table[60] = 2272; ima_step_table[61] = 2499;
  ima_step_table[62] = 2749; ima_step_table[63] = 3024;
  ima_step_table[64] = 3327; ima_step_table[65] = 3660;
  ima_step_table[66] = 4026; ima_step_table[67] = 4428;
  ima_step_table[68] = 4871; ima_step_table[69] = 5358;
  ima_step_table[70] = 5894; ima_step_table[71] = 6484;
  ima_step_table[72] = 7132; ima_step_table[73] = 7845;
  ima_step_table[74] = 8630; ima_step_table[75] = 9493;
  ima_step_table[76] = 10442; ima_step_table[77] = 11487;
  ima_step_table[78] = 12635; ima_step_table[79] = 13899;
  ima_step_table[80] = 15289; ima_step_table[81] = 16818;
  ima_step_table[82] = 18500; ima_step_table[83] = 20350;
  ima_step_table[84] = 22385; ima_step_table[85] = 24623;
  ima_step_table[86] = 27086; ima_step_table[87] = 29794;
  ima_step_table[88] = 32767;
  
  // IMA index adjustment table
  ima_index_table[0] = -1; ima_index_table[1] = -1;
  ima_index_table[2] = -1; ima_index_table[3] = -1;
  ima_index_table[4] = 2;  ima_index_table[5] = 4;
  ima_index_table[6] = 6;  ima_index_table[7] = 8;
  
  // PSX ADPCM filter coefficients
  psx_filter[0] = 0;       psx_filter[1] = 0;
  psx_filter[2] = 0.9375;  psx_filter[3] = 0;
  psx_filter[4] = 1.796875; psx_filter[5] = -0.8125;
  psx_filter[6] = 1.53125; psx_filter[7] = -0.859375;
  psx_filter[8] = 1.90625; psx_filter[9] = -0.9375;
);

init_tables();

// State variables
hold_L = 0;
hold_R = 0;
src_phase = 0;
last_play_state = 0;

// ============================================================================
// DSP FUNCTIONS
// ============================================================================

function clip(x) ( max(-1, min(1, x)); );

function soft_saturate(x, amount)
local(driven, wet)
(
  driven = x * (1 + amount * 3);
  wet = tanh_approx(driven);
  wet = wet / (1 + amount * 0.5);
  x * (1 - amount) + wet * amount;
);

function quantize_bits(input, bits)
local(levels, quant)
(
  bits == 1 ? (
    input;
  ) : (
    levels = pow(2, bits);
    quant = floor(input * levels * 0.5 + 0.5) / (levels * 0.5);
    clip(quant);
  );
);

// Apple 1-bit with DC blocker and proper feedback (FIXED)
function onebit_process(input, is_right)
local(delta, dc_state, output, artifact_scaled, threshold, error)
(
  artifact_scaled = scale_artifacts(smooth_artifacts);
  
  is_right ? (
    delta = onebit_delta_R;
    dc_state = onebit_dc_R;
  ) : (
    delta = onebit_delta_L;
    dc_state = onebit_dc_L;
  );
  
  // Comparator with error feedback
  threshold = 0.005 + artifact_scaled * 0.05;
  error = input - delta;
  
  error > threshold ? (
    output = 0.8;
  ) : error < -threshold ? (
    output = -0.8;
  ) : (
    // In dead zone - use input polarity
    output = input >= 0 ? 0.8 : -0.8;
  );
  
  // Update integrator with leak to prevent DC latch
  delta = delta * 0.97 + output * 0.03;
  delta = delta * 0.999;  // Slow leak toward zero
  
  // Characteristic quantization noise
  output += (rand() - 0.5) * artifact_scaled * 0.03;
  
  // DC blocker - prevents output from latching to constant offset
  dc_state = output - dc_state + 0.995 * dc_state;
  output = dc_state;
  
  is_right ? (
    onebit_delta_R = delta;
    onebit_dc_R = dc_state;
  ) : (
    onebit_delta_L = delta;
    onebit_dc_L = dc_state;
  );
  
  clip(output);
);

// N64 VADPCM with authentic table
function vadpcm_process(input, is_right)
local(pred1, pred2, coef1, coef2, prediction, quantized, output, artifact_scaled, table_idx)
(
  artifact_scaled = scale_artifacts(smooth_artifacts);
  
  is_right ? (
    pred1 = predictor_R;
    pred2 = predictor_R2;
  ) : (
    pred1 = predictor_L;
    pred2 = predictor_L2;
  );
  
  table_idx = min(4, floor(artifact_scaled * 5));
  coef1 = vadpcm_table[table_idx * 2];
  coef2 = vadpcm_table[table_idx * 2 + 1];
  
  prediction = pred1 * coef1 + pred2 * coef2;
  
  quantized = input;
  artifact_scaled > 0.01 ? (
    quantized = floor(input * (64 - artifact_scaled * 60) + 0.5) / (64 - artifact_scaled * 60);
  );
  
  output = quantized * (1 - artifact_scaled * 0.7) + prediction * artifact_scaled * 0.7;
  output += (rand() - 0.5) * artifact_scaled * (0.005 + artifact_scaled * 0.03);
  
  output = clip(output);
  
  is_right ? (
    predictor_R2 = pred1;
    predictor_R = output;
  ) : (
    predictor_L2 = pred1;
    predictor_L = output;
  );
  
  output;
);

// IMA ADPCM with authentic step table
function ima_process(input, is_right)
local(pred, step_idx, diff, nibble, delta, step_size, artifact_scaled, step)
(
  artifact_scaled = scale_artifacts(smooth_artifacts);
  
  pred = is_right ? predictor_R : predictor_L;
  step_idx = is_right ? step_index_R : step_index_L;
  
  step_idx = max(0, min(88, step_idx));
  step = ima_step_table[step_idx];
  step *= (1 + artifact_scaled * 3);
  
  diff = (input - pred) * 32768;
  nibble = min(7, max(-8, floor(diff / step + 0.5)));
  
  delta = nibble * step;
  pred += delta / 32768;
  pred += (rand() - 0.5) * artifact_scaled * step / 32768;
  
  pred = clip(pred);
  
  step_idx += ima_index_table[abs(nibble) < 8 ? abs(nibble) : 7];
  step_idx = max(0, min(88, step_idx));
  
  is_right ? (
    predictor_R = pred;
    step_index_R = step_idx;
  ) : (
    predictor_L = pred;
    step_index_L = step_idx;
  );
  
  pred;
);

// PSX ADPCM
function psx_adpcm_process(input, is_right)
local(s1, s2, k0, k1, sample, filter_idx, artifact_scaled, quant_levels)
(
  artifact_scaled = scale_artifacts(smooth_artifacts);
  
  is_right ? (
    s1 = psx_s1_R;
    s2 = psx_s2_R;
  ) : (
    s1 = psx_s1_L;
    s2 = psx_s2_L;
  );
  
  filter_idx = min(4, floor(artifact_scaled * 5));
  k0 = psx_filter[filter_idx * 2];
  k1 = psx_filter[filter_idx * 2 + 1];
  
  quant_levels = 16 - artifact_scaled * 14;
  sample = floor(input * quant_levels + 0.5) / quant_levels;
  
  sample = sample + s1 * k0 + s2 * k1;
  sample *= 0.98;
  sample += (rand() - 0.5) * artifact_scaled * 0.015;
  
  sample = clip(sample);
  
  is_right ? (
    psx_s2_R = s1;
    psx_s1_R = sample;
  ) : (
    psx_s2_L = s1;
    psx_s1_L = sample;
  );
  
  sample;
);

// 4-bit PCM
function pcm4_process(input, is_right)
local(quantized, artifact_scaled)
(
  artifact_scaled = scale_artifacts(smooth_artifacts);
  input += (rand() - 0.5) * (0.002 + artifact_scaled * 0.05);
  quantized = floor(input * (8 - artifact_scaled * 6) + 0.5) / (8 - artifact_scaled * 6);
  clip(quantized);
);

// Anti-aliasing filter with proper state handling
function aa_filter(input, is_right, cutoff)
local(coef, filtered, state)
(
  coef = exp(-2 * $pi * cutoff / srate);
  is_right ? (
    aa_lpf_R = aa_lpf_R * coef + input * (1 - coef);
    filtered = aa_lpf_R;
  ) : (
    aa_lpf_L = aa_lpf_L * coef + input * (1 - coef);
    filtered = aa_lpf_L;
  );
  filtered;
);

// Lo-fi filter with proper state handling
function lofi_filter_process(input, is_right, cutoff)
local(coef, filtered)
(
  coef = exp(-2 * $pi * cutoff / srate);
  is_right ? (
    lpf_a0_R = lpf_a0_R * coef + input * (1 - coef);
    filtered = lpf_a0_R;
  ) : (
    lpf_a0_L = lpf_a0_L * coef + input * (1 - coef);
    filtered = lpf_a0_L;
  );
  filtered;
);

// Reset filter states - called on playback start
function reset_filter_states()
(
  lpf_a0_L = 0;
  lpf_a0_R = 0;
  aa_lpf_L = 0;
  aa_lpf_R = 0;
  hold_L = 0;
  hold_R = 0;
  onebit_delta_L = 0;
  onebit_delta_R = 0;
  onebit_dc_L = 0;
  onebit_dc_R = 0;
  predictor_L = 0;
  predictor_R = 0;
  predictor_L2 = 0;
  predictor_R2 = 0;
  psx_s1_L = 0;
  psx_s2_L = 0;
  psx_s1_R = 0;
  psx_s2_R = 0;
  step_index_L = 0;
  step_index_R = 0;
  src_phase = 0;
);

// ============================================================================
// GUI FUNCTIONS
// ============================================================================

function get_sr_from_normalized(val)
local(project_rate, min_val)
(
  project_rate = srate;
  
  // If Apple 1-bit is selected, enforce minimum 44.1kHz
  gui_codec == 4 && val < 0.833 ? (
    sample_rate_limited = 1;
    val = 0.833;
  ) : (
    sample_rate_limited = 0;
  );
  
  8000 * pow(project_rate / 8000, val);
);

function get_sr_at_notch(notch_idx)
(
  notch_idx == 0 ? 8000 :
  notch_idx == 1 ? 11025 :
  notch_idx == 2 ? 16000 :
  notch_idx == 3 ? 22050 :
  notch_idx == 4 ? 32000 :
  notch_idx == 5 ? 44100 :
  srate;
);

function get_bit_from_normalized(val)
(
  1 + val * 15;
);

function get_bit_at_notch(notch_idx)
(
  notch_idx == 0 ? 1 :
  notch_idx == 1 ? 2 :
  notch_idx == 2 ? 4 :
  notch_idx == 3 ? 6 :
  notch_idx == 4 ? 8 :
  notch_idx == 5 ? 12 :
  16;
);

function format_sr_text(hz)
local(khz)
(
  khz = hz / 1000;
  khz >= 10 ? sprintf(#, "%.1fk", khz) : sprintf(#, "%.2fk", khz);
);

function format_bit_text(bits)
(
  bits < 1.5 ? sprintf(#, "1-bit") : 
  sprintf(#, "%.1f-bit", bits);
);

function draw_stepped_slider(x, y, w, value, title, slider_id, is_sample_rate)
local(i, notch_x, handle_x, handle_size, hovering, display_text, track_hovering, 
      notch_count, notch_val, notch_hz, notch_bits, notch_enabled)
(
  // Title
  gfx_set(FG_COLOR * 0.6, FG_COLOR * 0.6, FG_COLOR * 0.65);
  gfx_setfont(1, "Arial", 11);
  gfx_x = x; gfx_y = y - 18;
  gfx_drawstr(title);
  
  // Warning if 1-bit codec and sample rate is limited
  sample_rate_limited && is_sample_rate ? (
    gfx_set(LIMIT_COLOR_R, LIMIT_COLOR_G, LIMIT_COLOR_B);
    gfx_setfont(1, "Arial", 9);
    gfx_x = x + 90; gfx_y = y - 18;
    gfx_drawstr(" (Min 44.1kHz for 1-bit)");
  );
  
  // Check hover
  track_hovering = (dragging_slider == -1 || dragging_slider == slider_id) &&
                   mouse_x >= x - 10 && mouse_x <= x + w + 10 && 
                   mouse_y >= y - 10 && mouse_y <= y + SLIDER_HEIGHT + 10;
  
  // Track
  track_hovering ? (
    gfx_set(TRACK_COLOR * 1.2, TRACK_COLOR * 1.2, TRACK_COLOR * 1.3);
  ) : (
    gfx_set(TRACK_COLOR, TRACK_COLOR, TRACK_COLOR * 1.1);
  );
  gfx_rect(x, y, w, SLIDER_HEIGHT);
  
  // Draw notches
  notch_count = 7;
  i = 0;
  loop(notch_count,
    is_sample_rate ? (
      i == 6 ? (
        notch_val = 1.0;
        notch_hz = srate;
      ) : (
        notch_hz = get_sr_at_notch(i);
        notch_val = log(notch_hz / 8000) / log(srate / 8000);
      );
      notch_enabled = !(gui_codec == 4 && i < 5);
    ) : (
      notch_bits = get_bit_at_notch(i);
      notch_val = (notch_bits - 1) / 15.0;
      notch_enabled = 1;
    );
    
    notch_x = x + notch_val * w;
    
    notch_enabled ? (
      gfx_set(NOTCH_COLOR, NOTCH_COLOR, NOTCH_COLOR);
    ) : (
      gfx_set(NOTCH_COLOR * 0.3, NOTCH_COLOR * 0.3, NOTCH_COLOR * 0.3);
    );
    gfx_rect(notch_x - 1, y - 4, 2, SLIDER_HEIGHT + 8);
    
    notch_enabled ? (
      gfx_set(FG_COLOR * 0.4, FG_COLOR * 0.4, FG_COLOR * 0.45);
    ) : (
      gfx_set(FG_COLOR * 0.2, FG_COLOR * 0.2, FG_COLOR * 0.2);
    );
    gfx_setfont(1, "Arial", 9);
    
    is_sample_rate ? (
      i == 6 ? (
        display_text = sprintf(#, "PRJ");
      ) : (
        display_text = format_sr_text(notch_hz);
      );
    ) : (
      display_text = sprintf(#, "%d", notch_bits);
    );
    
    gfx_x = notch_x - strlen(display_text) * 3;
    gfx_y = y + SLIDER_HEIGHT + 5;
    gfx_drawstr(display_text);
    
    i += 1;
  );
  
  // Value fill
  sample_rate_limited && is_sample_rate ? (
    gfx_set(LIMIT_COLOR_R * 0.7, LIMIT_COLOR_G * 0.7, LIMIT_COLOR_B * 0.7);
  ) : fine_control_active && dragging_slider == slider_id ? (
    gfx_set(FINE_COLOR_R * 0.7, FINE_COLOR_G * 0.7, FINE_COLOR_B * 0.7);
  ) : (
    gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
  );
  gfx_rect(x, y, w * value, SLIDER_HEIGHT);
  
  // Handle
  handle_x = x + w * value;
  handle_size = 18;
  
  hovering = track_hovering;
  
  hovering || dragging_slider == slider_id ? (
    sample_rate_limited && is_sample_rate ? (
      gfx_set(LIMIT_COLOR_R, LIMIT_COLOR_G, LIMIT_COLOR_B);
    ) : fine_control_active && dragging_slider == slider_id ? (
      gfx_set(FINE_COLOR_R, FINE_COLOR_G, FINE_COLOR_B);
    ) : (
      gfx_set(FG_COLOR, FG_COLOR, FG_COLOR);
    );
  ) : (
    gfx_set(FG_COLOR * 0.8, FG_COLOR * 0.8, FG_COLOR * 0.85);
  );
  
  gfx_circle(handle_x, y + SLIDER_HEIGHT/2, handle_size/2, 1);
  
  // Current value display
  sample_rate_limited && is_sample_rate ? (
    gfx_set(LIMIT_COLOR_R, LIMIT_COLOR_G, LIMIT_COLOR_B);
  ) : fine_control_active && dragging_slider == slider_id ? (
    gfx_set(FINE_COLOR_R, FINE_COLOR_G, FINE_COLOR_B);
  ) : (
    gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
  );
  gfx_setfont(1, "Arial", 12, 'b');
  gfx_x = x + w + 15;
  gfx_y = y - 4;
  
  is_sample_rate ? (
    display_text = format_sr_text(display_sr_val);
  ) : (
    display_text = format_bit_text(display_bit_val);
  );
  gfx_drawstr(display_text);
  
  hovering;
);

function draw_smooth_slider(x, y, w, value, title, display_val, slider_id)
local(handle_x, handle_size, hovering)
(
  gfx_set(FG_COLOR * 0.6, FG_COLOR * 0.6, FG_COLOR * 0.65);
  gfx_setfont(1, "Arial", 11);
  gfx_x = x; gfx_y = y - 18;
  gfx_drawstr(title);
  
  hovering = (dragging_slider == -1 || dragging_slider == slider_id) &&
             mouse_x >= x - 10 && mouse_x <= x + w + 10 && 
             mouse_y >= y - 10 && mouse_y <= y + SLIDER_HEIGHT + 10;
  
  hovering ? (
    gfx_set(TRACK_COLOR * 1.2, TRACK_COLOR * 1.2, TRACK_COLOR * 1.3);
  ) : (
    gfx_set(TRACK_COLOR, TRACK_COLOR, TRACK_COLOR * 1.1);
  );
  gfx_rect(x, y, w, SLIDER_HEIGHT);
  
  gfx_set(ACCENT_R * 0.8, ACCENT_G * 0.8, ACCENT_B * 0.8);
  gfx_rect(x, y, w * value, SLIDER_HEIGHT);
  
  handle_x = x + w * value;
  handle_size = 16;
  
  hovering || dragging_slider == slider_id ? (
    gfx_set(FG_COLOR, FG_COLOR, FG_COLOR);
  ) : (
    gfx_set(FG_COLOR * 0.7, FG_COLOR * 0.7, FG_COLOR * 0.75);
  );
  
  gfx_circle(handle_x, y + SLIDER_HEIGHT/2, handle_size/2, 1);
  
  gfx_set(FG_COLOR * 0.8, FG_COLOR * 0.8, FG_COLOR * 0.85);
  gfx_setfont(1, "Arial", 12);
  gfx_x = x + w + 15;
  gfx_y = y - 4;
  gfx_drawstr(#display_val);
  
  hovering;
);

function draw_dropdown(x, y, w, h, selected_idx, is_open)
local(label, hovering, i, item_y, item_hover)
(
  selected_idx == 0 ? label = "N64 VADPCM" :
  selected_idx == 1 ? label = "IMA ADPCM" :
  selected_idx == 2 ? label = "4-BIT PCM" :
  selected_idx == 3 ? label = "PSX ADPCM" :
  label = "APPLE 1-BIT";
  
  hovering = mouse_x >= x && mouse_x <= x + w && 
             mouse_y >= y && mouse_y <= y + h;
  
  is_open || hovering ? (
    gfx_set(TRACK_COLOR * 1.3, TRACK_COLOR * 1.3, TRACK_COLOR * 1.4);
  ) : (
    gfx_set(TRACK_COLOR, TRACK_COLOR, TRACK_COLOR * 1.1);
  );
  gfx_rect(x, y, w, h);
  
  gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
  gfx_setfont(1, "Arial", 12, 'b');
  gfx_x = x + 12;
  gfx_y = y + h/2 - 7;
  gfx_drawstr(label);
  
  gfx_set(FG_COLOR * 0.5, FG_COLOR * 0.5, FG_COLOR * 0.55);
  gfx_x = x + w - 25;
  gfx_y = y + h/2 - 7;
  is_open ? gfx_drawstr("▲") : gfx_drawstr("▼");
  
  item_hover = -1;
  is_open ? (
    i = 0;
    loop(5,
      item_y = y + h + i * h;
      
      mouse_x >= x && mouse_x <= x + w && 
      mouse_y >= item_y && mouse_y <= item_y + h ? (
        item_hover = i;
        gfx_set(TRACK_COLOR * 1.5, TRACK_COLOR * 1.5, TRACK_COLOR * 1.6);
      ) : (
        gfx_set(TRACK_COLOR * 1.2, TRACK_COLOR * 1.2, TRACK_COLOR * 1.3);
      );
      
      gfx_rect(x, item_y, w, h);
      
      i == selected_idx ? (
        gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
      ) : (
        gfx_set(FG_COLOR * 0.7, FG_COLOR * 0.7, FG_COLOR * 0.75);
      );
      
      gfx_setfont(1, "Arial", 11);
      gfx_x = x + 12;
      gfx_y = item_y + h/2 - 6;
      
      i == 0 ? gfx_drawstr("N64 VADPCM") :
      i == 1 ? gfx_drawstr("IMA ADPCM") :
      i == 2 ? gfx_drawstr("4-BIT PCM") :
      i == 3 ? gfx_drawstr("PSX ADPCM") :
      (
        gfx_drawstr("APPLE 1-BIT");
        gfx_set(FG_COLOR * 0.5, FG_COLOR * 0.5, FG_COLOR * 0.55);
        gfx_setfont(1, "Arial", 9);
        gfx_drawstr(" (44k+ only)");
      );
      
      i += 1;
    );
  );
  
  dropdown_hover = item_hover;
  hovering;
);

function draw_checkbox(x, y, size, checked, label)
local(hovering)
(
  hovering = mouse_x >= x && mouse_x <= x + size + 100 && 
             mouse_y >= y && mouse_y <= y + size;
  
  hovering ? (
    gfx_set(TRACK_COLOR * 1.3, TRACK_COLOR * 1.3, TRACK_COLOR * 1.4);
  ) : (
    gfx_set(TRACK_COLOR, TRACK_COLOR, TRACK_COLOR * 1.1);
  );
  gfx_rect(x, y, size, size);
  
  checked ? (
    gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
    gfx_rect(x + 4, y + 4, size - 8, size - 8);
  );
  
  gfx_set(FG_COLOR * 0.7, FG_COLOR * 0.7, FG_COLOR * 0.75);
  gfx_setfont(1, "Arial", 11);
  gfx_x = x + size + 8;
  gfx_y = y + size/2 - 6;
  gfx_drawstr(label);
  
  hovering;
);

function snap_to_notch(value, is_sample_rate)
local(best_dist, best_val, i, notch_val, dist, notch_hz)
(
  best_dist = 1000;
  best_val = value;
  
  gui_codec == 4 && is_sample_rate ? (
    value < 0.833 ? best_val = 0.833;
  );
  
  i = 0;
  loop(7,
    is_sample_rate ? (
      i == 6 ? (
        notch_val = 1.0;
      ) : (
        notch_hz = get_sr_at_notch(i);
        notch_val = log(notch_hz / 8000) / log(srate / 8000);
      );
      gui_codec == 4 && i < 3 ? notch_val = -1;
    ) : (
      notch_val = (get_bit_at_notch(i) - 1) / 15.0;
    );
    
    notch_val >= 0 ? (
      dist = abs(value - notch_val);
      dist < best_dist ? (
        best_dist = dist;
        best_val = notch_val;
      );
    );
    i += 1;
  );
  
  best_val;
);

@slider
gui_sample_rate = sample_rate_idx / 4;
gui_bit_depth = bit_depth_idx / 3;
gui_drive = drive;
gui_output = output_gain;
gui_mix = dry_wet_mix;
gui_artifacts = artifact_amount;
gui_codec = codec_type;
gui_lofi = lofi_filter;
gui_aa = aa_filter;

display_sr_val = get_sr_from_normalized(gui_sample_rate);
display_bit_val = get_bit_from_normalized(gui_bit_depth);

sample_rates[6] = srate;

@block
// Detect playback start and reset filters to prevent clicks
play_state & 1 ? (
  !last_play_state ? (
    // Playback just started - reset all filter states
    reset_filter_states();
    startup_fade_samples = STARTUP_FADE_LENGTH;
  );
  last_play_state = 1;
) : (
  last_play_state = 0;
);

// Calculate target sample rate
target_srate = get_sr_from_normalized(gui_sample_rate);
src_ratio = srate / target_srate;

// Smooth parameter changes
smooth_drive += (gui_drive - smooth_drive) * 0.1;
smooth_artifacts += (gui_artifacts - smooth_artifacts) * 0.1;
smooth_mix += (gui_mix - smooth_mix) * 0.1;
smooth_output += (gui_output - smooth_output) * 0.1;

@gfx 440 460

// Background
gfx_set(BG_COLOR, BG_COLOR, BG_COLOR * 1.1);
gfx_rect(0, 0, gfx_w, gfx_h);

// Title
gfx_set(FG_COLOR, FG_COLOR, FG_COLOR);
gfx_setfont(1, "Arial", 18, 'b');
gfx_x = MARGIN; gfx_y = 20;
gfx_drawstr("RETRO CODEC");
gfx_set(ACCENT_R, ACCENT_G, ACCENT_B);
gfx_drawstr(" SUITE");

// Version
gfx_set(FG_COLOR * 0.3, FG_COLOR * 0.3, FG_COLOR * 0.35);
gfx_setfont(1, "Arial", 9);
gfx_x = MARGIN + 180; gfx_y = 27;
gfx_drawstr("v8.3");

// Codec dropdown label
dropdown_y = 60;
gfx_set(FG_COLOR * 0.4, FG_COLOR * 0.4, FG_COLOR * 0.45);
gfx_setfont(1, "Arial", 10);
gfx_x = MARGIN; gfx_y = dropdown_y - 18;
gfx_drawstr("CODEC TYPE");

// Sample rate slider
hovering_sr = draw_stepped_slider(MARGIN, 130, SLIDER_WIDTH, gui_sample_rate, 
                               "SAMPLE RATE", 1, 1);

// Control hints
gfx_setfont(1, "Arial", 9);
gfx_x = MARGIN + 50; gfx_y = 163;
fine_control_active ? (
  gfx_set(FINE_COLOR_R * 0.7, FINE_COLOR_G * 0.7, FINE_COLOR_B * 0.3);
  gfx_drawstr("Shift+Drag: Fine Control [ACTIVE] • ");
) : (
  gfx_set(FG_COLOR * 0.3, FG_COLOR * 0.3, FG_COLOR * 0.35);
  gfx_drawstr("Shift+Drag: Fine Control • ");
);
gfx_set(FG_COLOR * 0.3, FG_COLOR * 0.3, FG_COLOR * 0.35);
gfx_drawstr("Double-Click: Reset");

// Bit depth slider
hovering_bd = draw_stepped_slider(MARGIN, 195, SLIDER_WIDTH, gui_bit_depth, 
                               "BIT DEPTH", 2, 0);

// Drive slider
drive_text = 1700;
sprintf(#drive_text, "%d%%", floor(gui_drive * 100));
hovering_dr = draw_smooth_slider(MARGIN, 260, SLIDER_WIDTH, gui_drive, 
                              "SATURATION", drive_text, 3);

// Artifacts slider
art_text = 1800;
sprintf(#art_text, "%d%%", floor(gui_artifacts * 100));
hovering_art = draw_smooth_slider(MARGIN, 300, SLIDER_WIDTH, gui_artifacts,
                              "ARTIFACTS", art_text, 4);

// Mix slider
mix_text = 1900;
sprintf(#mix_text, "%d%%", floor(gui_mix * 100));
hovering_mix = draw_smooth_slider(MARGIN, 345, 145, gui_mix, "MIX", mix_text, 5);

// Output slider
out_text = 2000;
sprintf(#out_text, "%+.1fdB", (gui_output - 0.5) * 36 - 12);
hovering_out = draw_smooth_slider(MARGIN + 180, 345, 145, gui_output, 
                              "OUTPUT", out_text, 6);

// Checkboxes
checkbox_aa = draw_checkbox(MARGIN, 405, 16, gui_aa, "Anti-Aliasing");
checkbox_lofi = draw_checkbox(MARGIN + 140, 405, 16, gui_lofi, "Lo-Fi Filter");

// Footer
gfx_set(FG_COLOR * 0.25, FG_COLOR * 0.25, FG_COLOR * 0.3);
gfx_setfont(1, "Arial", 9);
gfx_x = MARGIN; gfx_y = gfx_h - 18;
gui_codec == 0 ? gfx_drawstr("Nintendo 64 Vector-Adaptive Differential PCM") :
gui_codec == 1 ? gfx_drawstr("Interactive Multimedia Association ADPCM Standard") :
gui_codec == 2 ? gfx_drawstr("4-bit Pulse Code Modulation with Error Diffusion") :
gui_codec == 3 ? gfx_drawstr("PlayStation 1 Adaptive Differential PCM") :
gfx_drawstr("Apple Macintosh 1-bit Comparator (44.1kHz minimum for stability)");

// Draw dropdown last for z-order
hovering = draw_dropdown(MARGIN, dropdown_y, DROPDOWN_WIDTH, DROPDOWN_HEIGHT, 
                         gui_codec, dropdown_open);

// Mouse handling
fine_control_active = mouse_cap & 8;

mouse_cap & 1 ? (
  !mouse_was_down ? (
    current_time = time_precise();
    is_double_click = (current_time - last_click_time) < DOUBLE_CLICK_TIME;
    
    // Dropdown
    mouse_x >= MARGIN && mouse_x <= MARGIN + DROPDOWN_WIDTH &&
    mouse_y >= dropdown_y && mouse_y <= dropdown_y + DROPDOWN_HEIGHT ? (
      dropdown_open = !dropdown_open;
      last_click_slider = -1;
    ) : dropdown_open && dropdown_hover >= 0 ? (
      gui_codec = dropdown_hover;
      codec_type = dropdown_hover;
      
      gui_codec == 4 && gui_sample_rate < 0.833 ? (
        gui_sample_rate = 0.833;
        display_sr_val = get_sr_from_normalized(gui_sample_rate);
        sample_rate_idx = gui_sample_rate * 4;
        slider_automate(slider1);
      );
      
      slider_automate(slider7);
      dropdown_open = 0;
      last_click_slider = -1;
    ) : dropdown_open ? (
      dropdown_open = 0;
      last_click_slider = -1;
    ) : (
      hovering_sr ? (
        is_double_click && last_click_slider == 1 ? (
          gui_sample_rate = DEFAULT_SAMPLE_RATE;
          display_sr_val = get_sr_from_normalized(gui_sample_rate);
          sample_rate_idx = gui_sample_rate * 4;
          slider_automate(slider1);
        ) : (
          dragging_slider = 1;
        );
        last_click_slider = 1;
      ) : hovering_bd ? (
        is_double_click && last_click_slider == 2 ? (
          gui_bit_depth = DEFAULT_BIT_DEPTH;
          display_bit_val = get_bit_from_normalized(gui_bit_depth);
          bit_depth_idx = gui_bit_depth * 3;
          slider_automate(slider2);
        ) : (
          dragging_slider = 2;
        );
        last_click_slider = 2;
      ) : hovering_dr ? (
        is_double_click && last_click_slider == 3 ? (
          gui_drive = DEFAULT_DRIVE;
          drive = gui_drive;
          slider_automate(slider3);
        ) : (
          dragging_slider = 3;
        );
        last_click_slider = 3;
      ) : hovering_art ? (
        is_double_click && last_click_slider == 4 ? (
          gui_artifacts = DEFAULT_ARTIFACTS;
          artifact_amount = gui_artifacts;
          slider_automate(slider6);
        ) : (
          dragging_slider = 4;
        );
        last_click_slider = 4;
      ) : hovering_mix ? (
        is_double_click && last_click_slider == 5 ? (
          gui_mix = DEFAULT_MIX;
          dry_wet_mix = gui_mix;
          slider_automate(slider5);
        ) : (
          dragging_slider = 5;
        );
        last_click_slider = 5;
      ) : hovering_out ? (
        is_double_click && last_click_slider == 6 ? (
          gui_output = DEFAULT_OUTPUT;
          output_gain = gui_output;
          slider_automate(slider4);
        ) : (
          dragging_slider = 6;
        );
        last_click_slider = 6;
      ) : (
        last_click_slider = -1;
      );
    );
    
    checkbox_aa ? (
      gui_aa = !gui_aa;
      aa_filter = gui_aa;
      slider_automate(slider9);
      last_click_slider = -1;
    );
    
    checkbox_lofi ? (
      gui_lofi = !gui_lofi;
      lofi_filter = gui_lofi;
      slider_automate(slider8);
      last_click_slider = -1;
    );
    
    last_click_time = current_time;
  );
  
  dragging_slider == 1 ? (
    gui_sample_rate = (mouse_x - MARGIN) / SLIDER_WIDTH;
    gui_sample_rate = max(0, min(1, gui_sample_rate));
    
    gui_codec == 4 && gui_sample_rate < 0.833 ? (
      gui_sample_rate = 0.833;
    );
    
    !fine_control_active ? (
      gui_sample_rate = snap_to_notch(gui_sample_rate, 1);
    );
    
    display_sr_val = get_sr_from_normalized(gui_sample_rate);
    sample_rate_idx = gui_sample_rate * 4;
    slider_automate(slider1);
    
  ) : dragging_slider == 2 ? (
    gui_bit_depth = (mouse_x - MARGIN) / SLIDER_WIDTH;
    gui_bit_depth = max(0, min(1, gui_bit_depth));
    
    !fine_control_active ? (
      gui_bit_depth = snap_to_notch(gui_bit_depth, 0);
    );
    
    display_bit_val = get_bit_from_normalized(gui_bit_depth);
    bit_depth_idx = gui_bit_depth * 3;
    slider_automate(slider2);
    
  ) : dragging_slider == 3 ? (
    gui_drive = (mouse_x - MARGIN) / SLIDER_WIDTH;
    gui_drive = max(0, min(1, gui_drive));
    drive = gui_drive;
    slider_automate(slider3);
    
  ) : dragging_slider == 4 ? (
    gui_artifacts = (mouse_x - MARGIN) / SLIDER_WIDTH;
    gui_artifacts = max(0, min(1, gui_artifacts));
    artifact_amount = gui_artifacts;
    slider_automate(slider6);
    
  ) : dragging_slider == 5 ? (
    gui_mix = (mouse_x - MARGIN) / 145;
    gui_mix = max(0, min(1, gui_mix));
    dry_wet_mix = gui_mix;
    slider_automate(slider5);
    
  ) : dragging_slider == 6 ? (
    gui_output = (mouse_x - (MARGIN + 180)) / 145;
    gui_output = max(0, min(1, gui_output));
    output_gain = gui_output;
    slider_automate(slider4);
  );
) : (
  dragging_slider = -1;
);

mouse_was_down = mouse_cap & 1;

@sample
// Get current settings
current_bits = get_bit_from_normalized(gui_bit_depth);

// Store dry signal
dry_L = spl0;
dry_R = spl1;

// Apply saturation
in_L = soft_saturate(spl0, smooth_drive);
in_R = soft_saturate(spl1, smooth_drive);

// Anti-aliasing filter
gui_aa ? (
  aa_cutoff = target_srate * 0.45;
  in_L = aa_filter(in_L, 0, aa_cutoff);
  in_R = aa_filter(in_R, 1, aa_cutoff);
);

// Sample rate reduction
src_phase += 1 / src_ratio;
src_phase >= 1.0 ? (
  src_phase -= 1.0;
  
  // Bit reduction (except for 1-bit)
  current_bits > 1.5 ? (
    in_L = quantize_bits(in_L, current_bits);
    in_R = quantize_bits(in_R, current_bits);
  );
  
  // Codec processing
  gui_codec == 0 ? (
    hold_L = vadpcm_process(in_L, 0);
    hold_R = vadpcm_process(in_R, 1);
  ) : gui_codec == 1 ? (
    hold_L = ima_process(in_L, 0);
    hold_R = ima_process(in_R, 1);
  ) : gui_codec == 2 ? (
    hold_L = pcm4_process(in_L, 0);
    hold_R = pcm4_process(in_R, 1);
  ) : gui_codec == 3 ? (
    hold_L = psx_adpcm_process(in_L, 0);
    hold_R = psx_adpcm_process(in_R, 1);
  ) : (
    hold_L = onebit_process(in_L, 0);
    hold_R = onebit_process(in_R, 1);
  );
);

// Lo-fi filter
gui_lofi ? (
  lofi_cutoff = target_srate * 0.4;
  hold_L = lofi_filter_process(hold_L, 0, lofi_cutoff);
  hold_R = lofi_filter_process(hold_R, 1, lofi_cutoff);
);

// Output with gain and mix
out_gain = db_to_linear((smooth_output - 0.5) * 36 - 12);

// Startup fade to prevent clicks
startup_fade_samples > 0 ? (
  startup_fade = 1.0 - (startup_fade_samples / STARTUP_FADE_LENGTH);
  startup_fade_samples -= 1;
) : (
  startup_fade = 1.0;
);

spl0 = (hold_L * smooth_mix + dry_L * (1 - smooth_mix)) * out_gain * startup_fade;
spl1 = (hold_R * smooth_mix + dry_R * (1 - smooth_mix)) * out_gain * startup_fade;

// Final clip
spl0 = clip(spl0);
spl1 = clip(spl1);
