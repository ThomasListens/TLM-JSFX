desc:Seed Delay - Multi-Tap Edition (v6.0.1 Fixed)
author:Claude & Thomas
version: 6.0.1

slider1:1<1,12,1>-Delay Choice (Legacy)
slider2:0<0,1,1>Re-roll
slider3:0.3<0,1,0.01>Mix
slider4:0.3<0,1,0.01>Feedback
slider5:0<0,500,1>Min Delay (ms)
slider6:1000<50,3000,1>Max Delay (ms)
slider7:0<0,4,1{Free,1/4 Note,1/2 Note,1/1 Note,2/1 Note}>Timing
slider8:0<0,7,1{Seed Random ⚡,Quantum Shuffle ⚛,Perlin Noise ∿,Spiral Wave ◉,Chromatic ÷,Harmonic ∑,Fibonacci φ,L-System ℒ}>Algorithm
slider9:0<0,1,1{Normal,Inverted}>Invert Values
slider10:0<0,1,0.01>Dirt
slider11:1<0.1,1,0.01>Saturation Ceiling

options:gfx_hz=30 no_meter

@init
ext_noinit = 1;

// Constants
MAX_TAPS = 12;
BUFFER_SIZE = 131072; // Must be power of 2
FEEDBACK_LIMIT = 0.95;
BLOCK_SMOOTH_HZ = 20;

// Initialize state variables
generation_count = 1;
last_reroll_state = 0;
last_timing_mode = -1;
last_algorithm = -1;
last_invert_mode = 0;

// UI State Variables
dragging_volume = -1;
dragging_pan = -1;
dragging_hpf = -1;
dragging_lpf = -1;
gfx_update_counter = 0;
last_mouse_x = -1;
last_mouse_y = -1;
last_mouse_cap = 0;
gfx_needs_update = 1;

// Helper functions
function tanh(x) (
  x = max(-3, min(3, x));
  (exp(2*x) - 1) / (exp(2*x) + 1)
);

// Saike-style SVF filter
function init_svf() 
instance(ic1eq, ic2eq)
(
  ic1eq = ic2eq = 0;
);

function eval_svf(v0, cutoff, Q) 
instance(ic1eq, ic2eq, v1, v2, v3)
local(g, k, a1, a2, a3)
(
  cutoff = max(10, min(0.45 * srate, cutoff));
  
  g = tan(0.5 * $pi * cutoff / srate);
  k = 1/max(0.5, Q);
  a1 = 1/(1 + g * (g + k));
  a2 = g * a1;
  a3 = g * a2;
  
  v3 = v0 - ic2eq;
  v1 = a1 * ic1eq + a2 * v3;
  v2 = ic2eq + a2 * ic1eq + a3 * v3;
  ic1eq = 2 * v1 - ic1eq;
  ic2eq = 2 * v2 - ic2eq;
  
  v1; // Return lowpass
);

function eval_svf_hp(v0, cutoff, Q) 
instance(ic1eq, ic2eq, v1, v2, v3)
local(g, k, a1, a2, a3)
(
  cutoff = max(10, min(0.45 * srate, cutoff));
  
  g = tan(0.5 * $pi * cutoff / srate);
  k = 1/max(0.5, Q);
  a1 = 1/(1 + g * (g + k));
  a2 = g * a2;
  a3 = g * a2;
  
  v3 = v0 - ic2eq;
  v1 = a1 * ic1eq + a2 * v3;
  v2 = ic2eq + a2 * ic1eq + a3 * v3;
  ic1eq = 2 * v1 - ic1eq;
  ic2eq = 2 * v2 - ic2eq;
  
  v0 - k * v1 - v2; // Fixed highpass calculation
);

// DC blocker
function dc_block(x) 
instance(y1, x1)
(
  y1 = x - x1 + 0.995 * y1;
  x1 = x;
  y1
);

// Improved interpolation (4-point Hermite)
function hermite_interp(buffer, pos, size)
local(pos_int, pos_frac, idx0, idx1, idx2, idx3, c0, c1, c2, c3, y0, y1, y2, y3)
(
  pos_int = floor(pos);
  pos_frac = pos - pos_int;
  
  idx0 = (pos_int - 1) & (size - 1);
  idx1 = pos_int & (size - 1);
  idx2 = (pos_int + 1) & (size - 1);
  idx3 = (pos_int + 2) & (size - 1);
  
  y0 = buffer[idx0];
  y1 = buffer[idx1];
  y2 = buffer[idx2];
  y3 = buffer[idx3];
  
  c0 = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;
  c1 = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;
  c2 = -0.5 * y0 + 0.5 * y2;
  c3 = y1;
  
  ((c0 * pos_frac + c1) * pos_frac + c2) * pos_frac + c3;
);

// Memory allocation
mem_base = 0;
mem_offset = 0;

// Delay buffers
delay_buffer_L = mem_base + mem_offset;
mem_offset += BUFFER_SIZE;
delay_buffer_R = mem_base + mem_offset;
mem_offset += BUFFER_SIZE;

// DC blocking states
dc_block_states = mem_base + mem_offset;
mem_offset += 32;

// Warmth filter states
warmth_states = mem_base + mem_offset;
mem_offset += 64;

// Tap data arrays
tap_selected = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_volumes = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_pans = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_volumes_smooth = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_pans_smooth = mem_base + mem_offset;
mem_offset += MAX_TAPS;

// Filter frequencies
tap_hpf_freq = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_lpf_freq = mem_base + mem_offset;
mem_offset += MAX_TAPS;

tap_filter_enabled = mem_base + mem_offset;
mem_offset += MAX_TAPS;

// Filter states - 4 values per SVF filter
tap_hp_states = mem_base + mem_offset;
mem_offset += MAX_TAPS * 4;

tap_lp_states = mem_base + mem_offset;
mem_offset += MAX_TAPS * 4;

// Algorithm storage
algo_storage = mem_base + mem_offset;
mem_offset += 8 * MAX_TAPS;

// Visual state tracking
last_drawn_volumes = mem_base + mem_offset;
mem_offset += MAX_TAPS;

last_drawn_pans = mem_base + mem_offset;
mem_offset += MAX_TAPS;

// Clear ALL memory
memset(mem_base, 0, mem_offset);

// Initialize tap defaults
i = 0;
loop(MAX_TAPS,
  tap_selected[i] = (i < 2) ? 1 : 0;
  tap_volumes[i] = 0.5;
  tap_volumes_smooth[i] = 0.5;
  tap_pans[i] = 0.0;
  tap_pans_smooth[i] = 0.0;
  last_drawn_volumes[i] = -999;
  last_drawn_pans[i] = -999;
  
  tap_hpf_freq[i] = 200.0;
  tap_lpf_freq[i] = 4000.0;
  tap_filter_enabled[i] = 0;
  
  // Initialize SVF states properly
  hp_state_base = tap_hp_states + i * 4;
  lp_state_base = tap_lp_states + i * 4;
  hp_state_base[0] = hp_state_base[1] = hp_state_base[2] = hp_state_base[3] = 0;
  lp_state_base[0] = lp_state_base[1] = lp_state_base[2] = lp_state_base[3] = 0;
  
  i += 1;
);

write_pos = 0;

// Initialize smoothing parameters
mix_smooth = slider3;
feedback_smooth = slider4;
warmth_smooth = slider10;
ceiling_smooth = slider11;

// Saike-style soft saturation
function soft_sat(x, ceiling)
local(x_scaled, abs_x)
(
  x_scaled = x / max(0.01, ceiling);
  abs_x = abs(x_scaled);
  abs_x > 1 ? (
    sign(x_scaled) * (1 + tanh(2 * (abs_x - 1)) * 0.2)
  ) : (
    x_scaled * (1 + 0.05 * x_scaled * x_scaled)
  ) * ceiling;
);

// Improved dirt/warmth filter
function warmth_process(x, amount)
instance(lp_state, hp_state, delay1, delay2)
local(freq, wet, bits, quant)
(
  amount = max(0, min(1, amount));
  
  // Subtle modulation
  freq = 2000 + (1 - amount) * 6000;
  lp_state = lp_state * 0.9 + x * 0.1;
  
  // Bit reduction
  amount > 0.1 ? (
    bits = 16 - floor(amount * 6);
    quant = 2^max(8, bits);
    wet = floor(x * quant + 0.5) / quant;
    x = x * (1 - amount * 0.3) + wet * amount * 0.3;
  );
  
  x * (1 + amount * 0.15);
);

// Fixed filter processing with proper SVF state management
function process_tap_filters(x, tap_index)
local(hp_out, lp_out, hp_state_base, lp_state_base, hp_freq, lp_freq)
(
  tap_filter_enabled[tap_index] ? (
    // Get state base addresses
    hp_state_base = tap_hp_states + tap_index * 4;
    lp_state_base = tap_lp_states + tap_index * 4;
    
    // Get frequencies with safety bounds
    hp_freq = max(20, min(8000, tap_hpf_freq[tap_index]));
    lp_freq = max(hp_freq + 100, min(16000, tap_lpf_freq[tap_index]));
    
    // Apply HP filter - create temp instance
    hp_filter.ic1eq = hp_state_base[0];
    hp_filter.ic2eq = hp_state_base[1];
    hp_out = hp_filter.eval_svf_hp(x, hp_freq, 0.7);
    hp_state_base[0] = hp_filter.ic1eq;
    hp_state_base[1] = hp_filter.ic2eq;
    
    // Apply LP filter - create temp instance  
    lp_filter.ic1eq = lp_state_base[0];
    lp_filter.ic2eq = lp_state_base[1];
    lp_out = lp_filter.eval_svf(hp_out, lp_freq, 0.7);
    lp_state_base[0] = lp_filter.ic1eq;
    lp_state_base[1] = lp_filter.ic2eq;
    
    lp_out;
  ) : x;
);

// Helper function to safely get/set algorithm values
function get_base_value(slot)
local(addr, val)
(
  slot >= 0 && slot < MAX_TAPS ? (
    addr = algo_storage + slider8 * MAX_TAPS + slot;
    val = max(0, min(1, addr[0]));
    slider9 > 0.5 ? val = 1.0 - val : val;
    val;
  ) : 0.5;
);

function set_algo_value(algo, slot, val)
local(addr)
(
  slot >= 0 && slot < MAX_TAPS && algo >= 0 && algo < 8 ? (
    addr = algo_storage + algo * MAX_TAPS + slot;
    addr[0] = max(0, min(1, val));
  );
);

// Fixed algorithm generation with proper bounds checking
function generate_algorithm_values(algo_num)
local(i, seed, val, angle, wave_phase, phi, a, b, c)
(
  algo_num == 0 ? (
    // Seed Random ⚡
    i = 0;
    loop(MAX_TAPS,
      seed = (generation_count * 7919 + i * 2654435761) & 2147483647;
      seed = (seed * 16807) & 2147483647;
      val = (seed / 2147483647.0) * 0.8 + 0.1;
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 1 ? (
    // Quantum Shuffle ⚛
    i = 0;
    loop(MAX_TAPS,
      val = (i + 0.5 + sin(generation_count * 0.1 + i)) / MAX_TAPS;
      val = max(0.05, min(0.95, val));
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 2 ? (
    // Perlin Noise ∿
    i = 0;
    loop(MAX_TAPS,
      a = sin(i * 0.8 + generation_count * 0.2);
      b = sin(i * 2.1 + generation_count * 0.15);
      val = 0.5 + 0.3 * a + 0.1 * b;
      val = max(0.1, min(0.9, val));
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 3 ? (
    // Spiral Wave ◉
    wave_phase = generation_count * 0.3;
    i = 0;
    loop(MAX_TAPS,
      angle = i * 0.523599;
      a = sin(angle * 2 + wave_phase);
      b = cos(angle * 3 + wave_phase * 0.7);
      val = 0.5 + 0.25 * a + 0.15 * b;
      val = max(0.15, min(0.85, val));
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 4 ? (
    // Chromatic ÷
    i = 0;
    loop(MAX_TAPS,
      val = (i + 1) / 12.0;
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 5 ? (
    // Harmonic Series ∑
    i = 0;
    loop(MAX_TAPS,
      val = (1.0 / (i + 1)) * 0.8 + 0.1;
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : algo_num == 6 ? (
    // Fibonacci φ
    phi = 1.618034;
    i = 0;
    loop(MAX_TAPS,
      val = abs(sin(i * phi + generation_count * 0.1)) * 0.7 + 0.15;
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  ) : (
    // L-System ℒ
    i = 0;
    loop(MAX_TAPS,
      a = sin(i * 1.41421 + generation_count * 0.31416);
      b = sin(i * 0.707 + generation_count * 0.1);
      val = 0.3 + 0.4 * abs(a) + 0.1 * b;
      val = max(0.1, min(0.9, val));
      set_algo_value(algo_num, i, val);
      i += 1;
    );
  );
);

// Helper functions
function get_delay_ms(slot)
local(base_val, min_val, max_val)
(
  slot >= 0 && slot < MAX_TAPS ? (
    base_val = get_base_value(slot);
    min_val = max(1, slider5);
    max_val = max(min_val + 10, slider6);
    min_val + base_val * (max_val - min_val);
  ) : 100;
);

function count_active_taps()
local(i, count)
(
  count = 0;
  i = 0;
  loop(MAX_TAPS,
    tap_selected[i] ? count += 1;
    i += 1;
  );
  count;
);

function is_dragging()
(
  dragging_volume >= 0 || dragging_pan >= 0 || 
  dragging_hpf >= 0 || dragging_lpf >= 0
);

// Initialize all algorithms at startup
i = 0;
loop(8,
  generate_algorithm_values(i);
  i += 1;
);

@slider
// Validate slider ranges
slider5 = max(0, min(2000, slider5));
slider6 = max(slider5 + 10, min(5000, slider6));
slider3 = max(0, min(1, slider3));
slider4 = max(0, min(FEEDBACK_LIMIT, slider4));
slider10 = max(0, min(1, slider10));
slider11 = max(0.1, min(1, slider11));

// Re-roll on button press (rising edge)
slider2 > 0.5 && last_reroll_state <= 0.5 ? (
  generation_count += 1;
  generate_algorithm_values(slider8);
  gfx_needs_update = 1;
);
last_reroll_state = slider2;

// Handle timing mode changes
slider7 != last_timing_mode ? (
  slider7 > 0 && tempo > 0 ? (
    bpm = max(60, min(200, tempo));
    beat_ms = 60000 / bpm;
    slider7 == 1 ? slider6 = beat_ms * 0.25 :
    slider7 == 2 ? slider6 = beat_ms * 0.5 :
    slider7 == 3 ? slider6 = beat_ms * 1.0 :
    slider6 = beat_ms * 2.0;
    slider6 = max(10, min(3000, slider6));
  );
  last_timing_mode = slider7;
  gfx_needs_update = 1;
);

// Handle algorithm changes
slider8 != last_algorithm ? (
  last_algorithm = slider8;
  gfx_needs_update = 1;
);

// Handle invert changes
slider9 != last_invert_mode ? (
  last_invert_mode = slider9;
  gfx_needs_update = 1;
);

@block
// Calculate block-rate smoothing coefficient
block_samples = samplesblock;
block_smooth = 1 - exp(-2 * $pi * BLOCK_SMOOTH_HZ * block_samples / srate);

// Smooth tap parameters at block rate
i = 0;
loop(MAX_TAPS,
  tap_volumes_smooth[i] += block_smooth * (tap_volumes[i] - tap_volumes_smooth[i]);
  tap_pans_smooth[i] += block_smooth * (tap_pans[i] - tap_pans_smooth[i]);
  i += 1;
);

// Smooth main parameters
mix_target = slider3;
feedback_target = slider4;
warmth_target = slider10;
ceiling_target = slider11;

mix_smooth += block_smooth * (mix_target - mix_smooth);
feedback_smooth += block_smooth * (feedback_target - feedback_smooth);
warmth_smooth += block_smooth * (warmth_target - warmth_smooth);
ceiling_smooth += block_smooth * (ceiling_target - ceiling_smooth);

@sample
// Input with DC blocking
input_L = dc_L.dc_block(spl0);
input_R = dc_R.dc_block(spl1);

// Apply warmth if enabled
warmth_smooth > 0.01 ? (
  input_L = warmth_L.warmth_process(input_L, warmth_smooth);
  input_R = warmth_R.warmth_process(input_R, warmth_smooth);
);

// Process delay taps
mix_L = 0;
mix_R = 0;
total_gain = 0;

i = 0;
loop(MAX_TAPS,
  tap_selected[i] ? (
    // Get smoothed parameters
    tap_gain = tap_volumes_smooth[i];
    tap_pan = tap_pans_smooth[i];
    
    // Calculate delay with bounds checking
    delay_ms = get_delay_ms(i);
    delay_samples = (delay_ms / 1000) * srate;
    delay_samples = max(4, min(BUFFER_SIZE - 4, delay_samples));
    
    // Read position with proper wrapping
    read_pos = write_pos - delay_samples;
    read_pos < 0 ? read_pos += BUFFER_SIZE;
    
    // High-quality interpolation
    delayed_L = hermite_interp(delay_buffer_L, read_pos, BUFFER_SIZE);
    delayed_R = hermite_interp(delay_buffer_R, read_pos, BUFFER_SIZE);
    
    // Apply tap filters if enabled
    delayed_L = process_tap_filters(delayed_L, i);
    delayed_R = process_tap_filters(delayed_R, i);
    
    // Equal-power panning
    pan_angle = (tap_pan + 1) * $pi * 0.25;
    pan_L = cos(pan_angle);
    pan_R = sin(pan_angle);
    
    // Accumulate
    mix_L += delayed_L * tap_gain * pan_L;
    mix_R += delayed_R * tap_gain * pan_R;
    total_gain += tap_gain;
  );
  i += 1;
);

// Normalize mix
total_gain > 0.01 ? (
  norm_factor = min(1.0, 1.0 / sqrt(total_gain));
  mix_L *= norm_factor;
  mix_R *= norm_factor;
) : (
  mix_L = 0;
  mix_R = 0;
);

// Feedback processing with safety limiting
feedback_amount = feedback_smooth * 0.9;
fb_L = mix_L * feedback_amount;
fb_R = mix_R * feedback_amount;

// Apply saturation to feedback
fb_L = soft_sat(fb_L, ceiling_smooth);
fb_R = soft_sat(fb_R, ceiling_smooth);

// Write to delay buffer
delay_buffer_L[write_pos] = input_L + fb_L;
delay_buffer_R[write_pos] = input_R + fb_R;

// Advance write position with proper wrapping
write_pos = (write_pos + 1) & (BUFFER_SIZE - 1);

// Output mix
dry_amount = 1 - mix_smooth;
wet_amount = mix_smooth;

output_L = input_L * dry_amount + mix_L * wet_amount;
output_R = input_R * dry_amount + mix_R * wet_amount;

// Final soft limiting
limiter_threshold = 0.95;
abs(output_L) > limiter_threshold ? (
  output_L = sign(output_L) * (limiter_threshold + 
    tanh(3 * (abs(output_L) - limiter_threshold)) * 0.05);
);
abs(output_R) > limiter_threshold ? (
  output_R = sign(output_R) * (limiter_threshold + 
    tanh(3 * (abs(output_R) - limiter_threshold)) * 0.05);
);

spl0 = output_L;
spl1 = output_R;

@gfx 370 470
// Helper function for needs_redraw
function needs_redraw()
local(changed, i)
(
  changed = 0;
  i = 0;
  loop(MAX_TAPS,
    abs(tap_volumes_smooth[i] - last_drawn_volumes[i]) > 0.001 ? changed = 1;
    abs(tap_pans_smooth[i] - last_drawn_pans[i]) > 0.001 ? changed = 1;
    last_drawn_volumes[i] = tap_volumes_smooth[i];
    last_drawn_pans[i] = tap_pans_smooth[i];
    i += 1;
  );
  changed || mouse_x != last_mouse_x || mouse_y != last_mouse_y || gfx_needs_update;
);

// Reduce update rate for stability
gfx_update_counter += 1;
(gfx_update_counter >= 3 || needs_redraw()) ? (
  gfx_update_counter = 0;
  gfx_needs_update = 0;
  
  // Cache mouse state
  _mouse_x = mouse_x;
  _mouse_y = mouse_y;
  _mouse_clicked = (mouse_cap & 1) && !(last_mouse_cap & 1);
  _mouse_down = mouse_cap & 1;
  _mouse_released = !(mouse_cap & 1) && (last_mouse_cap & 1);
  _ctrl_held = mouse_cap & 4;
  _alt_held = mouse_cap & 16;
  _shift_held = mouse_cap & 8;
  
  // Clear drag states on release
  _mouse_released ? (
    dragging_volume = -1;
    dragging_pan = -1;
    dragging_hpf = -1;
    dragging_lpf = -1;
  );
  
  // Clear background
  gfx_set(0.08, 0.08, 0.08, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
  
  // Title
  gfx_set(0.85, 0.85, 0.85, 1);
  gfx_x = 20; gfx_y = 15;
  gfx_drawstr("   S E E D   d e l a y   [v6.0.1 Fixed]");
  
  // Grid constants
  grid_x = 20; grid_y = 45; cell_w = 80; cell_h = 52;
  cols = 4; rows = 3;
  control_zone_height = 16;
  
  // Draw tap grid
  i = 0;
  loop(MAX_TAPS,
    // Calculate cell position
    col = i % cols;
    row = floor(i / cols);
    x = grid_x + col * cell_w;
    y = grid_y + row * cell_h;
    
    selected = tap_selected[i];
    
    // Zone calculations
    main_zone_h = cell_h - control_zone_height;
    control_zone_y = y + main_zone_h;
    
    // Center circle
    center_x = x + (cell_w - 3) / 2;
    center_y = y + main_zone_h / 2 + 4;
    circle_radius = 16;
    
    // Check if we're over this cell
    in_cell = _mouse_x >= x && _mouse_x < x + cell_w - 3 && 
              _mouse_y >= y && _mouse_y < y + cell_h - 3;
    in_main = in_cell && _mouse_y < control_zone_y;
    in_control = in_cell && _mouse_y >= control_zone_y;
    
    // Check circle click
    dist_from_center = sqrt((_mouse_x - center_x)^2 + (_mouse_y - center_y)^2);
    over_circle = dist_from_center <= circle_radius;
    
    // Toggle tap
    over_circle && _mouse_clicked && !is_dragging() ? (
      tap_selected[i] = !tap_selected[i];
    );
    
    // Cell background
    volume_intensity = tap_volumes_smooth[i];
    base_brightness = selected ? 0.14 : 0.1;
    green_channel = selected ? (0.22 + volume_intensity * 0.1) : 0.12;
    
    gfx_set(base_brightness, green_channel, base_brightness, 1);
    gfx_rect(x, y, cell_w - 3, cell_h - 3);
    
    // Border
    selected ? gfx_set(0.18, 0.3, 0.18, 1) : gfx_set(0.18, 0.18, 0.18, 1);
    gfx_rect(x, y, cell_w - 3, cell_h - 3, 0);
    
    // Center circle
    selected ? (
      gfx_set(0.08, 0.15, 0.08, 0.8);
      gfx_circle(center_x, center_y, circle_radius, 1);
      gfx_set(0.1, 0.2, 0.1, 0.9);
      gfx_circle(center_x, center_y, circle_radius - 2, 1);
      gfx_set(0.4, 0.8, 0.4, 1);
      gfx_circle(center_x, center_y, 2, 1);
    ) : (
      over_circle ? gfx_set(0.25, 0.35, 0.25, 0.4) : gfx_set(0.2, 0.3, 0.2, 0.3);
      gfx_circle(center_x, center_y, circle_radius, 1);
      gfx_set(0.25, 0.35, 0.25, 0.4);
      gfx_circle(center_x, center_y, 4, 1);
    );
    
    // Tap number
    selected ? gfx_set(0.9, 0.9, 0.9, 1) : gfx_set(0.6, 0.6, 0.6, 1);
    gfx_x = x + 6; gfx_y = y + 5;
    gfx_printf("%d", i + 1);
    
    // Base value
    gfx_x = i >= 9 ? x + 26 : x + 22;
    gfx_y = y + 5;
    gfx_set(0.65, 0.65, 0.65, 1);
    gfx_printf("%.3f", get_base_value(i));
    
    // Delay time
    delay_ms = get_delay_ms(i);
    gfx_x = x + 6; gfx_y = y + 18;
    gfx_set(0.75, 0.75, 0.75, 1);
    gfx_printf("%.0fms", delay_ms);
    
      // FILTER CONTROLS
      selected && tap_filter_enabled[i] ? (
        filter_handle_size = 4;
        filter_y = y + 2;
        
        // Calculate filter positions
        hpf_freq = tap_hpf_freq[i];
        hpf_norm = (log(max(50, hpf_freq)) - log(50)) / (log(1000) - log(50));
        hpf_x_start = x + 3;
        hpf_x_range = (cell_w - 3) / 2 - 6;
        hpf_handle_x = hpf_x_start + hpf_norm * hpf_x_range;
        hpf_handle_y = filter_y;
        
        lpf_freq = tap_lpf_freq[i];
        lpf_norm = (log(max(1000, lpf_freq)) - log(1000)) / (log(12000) - log(1000));
        lpf_x_start = x + (cell_w - 3) / 2 + 3;
        lpf_x_range = (cell_w - 3) / 2 - 6;
        lpf_handle_x = lpf_x_start + lpf_norm * lpf_x_range;
        lpf_handle_y = filter_y;
        
        // Check if over filter handles
        over_hpf = abs(_mouse_x - hpf_handle_x) < filter_handle_size &&
                   abs(_mouse_y - hpf_handle_y) < filter_handle_size;
        over_lpf = abs(_mouse_x - lpf_handle_x) < filter_handle_size &&
                   abs(_mouse_y - lpf_handle_y) < filter_handle_size;
        
        // Start filter drags
        _mouse_clicked && in_main && !over_circle && !is_dragging() ? (
          over_hpf ? (
            _ctrl_held ? tap_hpf_freq[i] = 100.0 : dragging_hpf = i;
          ) : over_lpf ? (
            _ctrl_held ? tap_lpf_freq[i] = 5000.0 : dragging_lpf = i;
          );
        );
        
        // Update filter values
        dragging_hpf == i && _mouse_down ? (
          drag_x = max(hpf_x_start, min(hpf_x_start + hpf_x_range, _mouse_x));
          drag_norm = (drag_x - hpf_x_start) / hpf_x_range;
          tap_hpf_freq[i] = 50 * exp(drag_norm * (log(1000) - log(50)));
        );
        
        dragging_lpf == i && _mouse_down ? (
          drag_x = max(lpf_x_start, min(lpf_x_start + lpf_x_range, _mouse_x));
          drag_norm = (drag_x - lpf_x_start) / lpf_x_range;
          tap_lpf_freq[i] = 1000 * exp(drag_norm * (log(12000) - log(1000)));
        );
        
        // Draw filter lines
        gfx_set(0.2, 0.35, 0.2, hpf_norm * 0.3);
        gfx_line(x + 2, control_zone_y - 2, hpf_handle_x, hpf_handle_y);
        
        gfx_set(0.2, 0.35, 0.2, lpf_norm * 0.3);
        gfx_line(lpf_handle_x, lpf_handle_y, x + cell_w - 5, control_zone_y - 2);
        
        // Draw handles
        dragging_hpf == i ? gfx_set(0.4, 0.6, 0.4, 1) :
        over_hpf ? gfx_set(0.35, 0.55, 0.35, 0.9) : 
        gfx_set(0.3, 0.5, 0.3, 0.8);
        gfx_rect(hpf_handle_x - filter_handle_size/2, hpf_handle_y - filter_handle_size/2, 
                 filter_handle_size, filter_handle_size);
        
        dragging_lpf == i ? gfx_set(0.4, 0.6, 0.4, 1) :
        over_lpf ? gfx_set(0.35, 0.55, 0.35, 0.9) : 
        gfx_set(0.3, 0.5, 0.3, 0.8);
        gfx_rect(lpf_handle_x - filter_handle_size/2, lpf_handle_y - filter_handle_size/2, 
                 filter_handle_size, filter_handle_size);
      );
      
      // Alt+click for filter toggle
      in_main && !over_circle && _mouse_clicked && _alt_held ? (
        tap_filter_enabled[i] = !tap_filter_enabled[i];
      );
      
      // PAN CONTROL
      selected ? (
        handle_width = 3;
        handle_height = 10;
        handle_y = control_zone_y + 3;
        
        pan_x_range = cell_w - 40;
        pan_x_start = x + 20;
        pan_norm = (tap_pans[i] + 1) * 0.5;
        pan_handle_x = pan_x_start + pan_norm * pan_x_range;
        
        // Check if over pan
        over_pan = abs(_mouse_x - pan_handle_x) < 5 && 
                   abs(_mouse_y - (handle_y + handle_height/2)) < 6;
        
        // Start pan drag
        in_control && _mouse_clicked && over_pan && !is_dragging() ? (
          _ctrl_held ? tap_pans[i] = 0.0 : dragging_pan = i;
        );
        
        // Update pan
        dragging_pan == i && _mouse_down ? (
          new_pan = ((_mouse_x - pan_x_start) / pan_x_range) * 2 - 1;
          tap_pans[i] = max(-1, min(1, new_pan));
        );
        
        // Draw guide line
        gfx_set(0.12, 0.18, 0.12, 0.2);
        gfx_line(pan_x_start, handle_y + handle_height/2, 
                 pan_x_start + pan_x_range, handle_y + handle_height/2);
        
        // Draw handle
        dragging_pan == i ? gfx_set(0.4, 0.6, 0.4, 1) :
        over_pan ? gfx_set(0.35, 0.55, 0.35, 0.9) : 
        gfx_set(0.3, 0.5, 0.3, 0.8);
        gfx_rect(pan_handle_x - handle_width/2, handle_y, handle_width, handle_height);
        
        // L|R indicator
        pan_abs = abs(tap_pans[i]);
        pan_abs > 0.05 ? (
          label_alpha = pan_abs * 0.8;
          gfx_set(0.3, 0.3, 0.3, label_alpha);
          
          tap_pans[i] < 0 ? (
            gfx_x = pan_handle_x - 12;
            gfx_y = handle_y + 1;
            gfx_drawstr("L|");
          ) : (
            gfx_x = pan_handle_x - 4;
            gfx_y = handle_y + 1;
            gfx_drawstr("|R");
          );
        ) : (
          gfx_set(0.2, 0.3, 0.2, 0.3);
          gfx_x = pan_handle_x - 2;
          gfx_y = handle_y + 1;
          gfx_drawstr("|");
        );
      );
      
      i += 1;
    ); // End of tap loop
    
      // VOLUME RECTANGLE
      vol_rect_y = grid_y + rows * cell_h + 10;
      vol_rect_h = 50;
      vol_rect_w = cols * cell_w - 3;
      
      // Background
      gfx_set(0.12, 0.12, 0.12, 1);
      gfx_rect(grid_x, vol_rect_y, vol_rect_w, vol_rect_h);
      
      // Border
      gfx_set(0.3, 0.3, 0.3, 1);
      gfx_rect(grid_x, vol_rect_y, vol_rect_w, vol_rect_h, 0);
      
      // Draw volume bars
      bar_w = vol_rect_w / 12;
      i = 0;
      loop(12,
        bar_x = grid_x + i * bar_w;
        bar_fill_h = tap_volumes[i] * (vol_rect_h - 4);
        bar_fill_y = vol_rect_y + vol_rect_h - 2 - bar_fill_h;
        
        // Check mouse over bar
        over_bar = _mouse_x >= bar_x && _mouse_x < bar_x + bar_w &&
                   _mouse_y >= vol_rect_y && _mouse_y < vol_rect_y + vol_rect_h;
        
        // Bar background
        over_bar ? gfx_set(0.22, 0.22, 0.22, 1) : gfx_set(0.18, 0.18, 0.18, 1);
        gfx_rect(bar_x + 1, vol_rect_y + 2, bar_w - 2, vol_rect_h - 4);
        
        // Bar fill
        tap_selected[i] ? (
          over_bar ? gfx_set(0.25, 0.7, 0.25, 1) : gfx_set(0.2, 0.6, 0.2, 1);
          gfx_rect(bar_x + 2, bar_fill_y, bar_w - 4, bar_fill_h);
        );
        
        // Tap number
        gfx_set(0.5, 0.5, 0.5, 1);
        gfx_x = bar_x + bar_w/2 - 3;
        gfx_y = vol_rect_y + vol_rect_h + 5;
        gfx_printf("%d", i + 1);
        
        // Volume interaction
        over_bar && _mouse_down && !is_dragging() ? (
          dragging_volume = i;
        );
        
        dragging_volume == i && _mouse_down ? (
          new_vol = 1.0 - (_mouse_y - vol_rect_y - 2) / (vol_rect_h - 4);
          new_vol = max(0.0, min(1.0, new_vol));
          tap_volumes[i] = new_vol;
        );
        
        over_bar && _mouse_clicked ? (
          _shift_held ? (
            tap_selected[i] = !tap_selected[i];
          ) : _ctrl_held ? (
            tap_volumes[i] = 0.7;
          );
        );
        
        i += 1;
      );
      
      // INFORMATION SECTION
      info_y = vol_rect_y + vol_rect_h + 25;
      
      // Row 1: Status
      active_count = count_active_taps();
      gfx_set(0.7, 0.7, 0.7, 1);
      gfx_x = 20; gfx_y = info_y;
      gfx_printf("Active: %d", active_count);
      
      gfx_x = 120;
      gfx_printf("Mix %.0f%%", slider3 * 100);
      
      gfx_x = 200;
      gfx_printf("FB %.0f%%", slider4 * 100);
      
      // Row 2: Algorithm
      gfx_x = 20; gfx_y = info_y + 18;
      gfx_set(0.65, 0.65, 0.65, 1);
      gfx_printf("Algorithm: %s",
        slider8 == 0 ? "Seed Random ⚡" :
        slider8 == 1 ? "Quantum Shuffle ⚛" :
        slider8 == 2 ? "Perlin Noise ∿" :
        slider8 == 3 ? "Spiral Wave ◉" :
        slider8 == 4 ? "Chromatic ÷" :
        slider8 == 5 ? "Harmonic ∑" :
        slider8 == 6 ? "Fibonacci φ" : "L-System ℒ"
      );
      
      // Row 3: Timing
      gfx_x = 20; gfx_y = info_y + 36;
      gfx_set(0.55, 0.55, 0.55, 1);
      slider7 == 0 ? (
        gfx_printf("Timing: Free %.0f-%.0fms", slider5, slider6);
      ) : (
        bpm = tempo > 0 ? tempo : 120;
        note_name = slider7 == 1 ? "1/4" :
                    slider7 == 2 ? "1/2" :
                    slider7 == 3 ? "1/1" : "2/1";
        gfx_printf("Timing: %s @ %.0f BPM", note_name, bpm);
      );
      
      // Dynamic/Static indicator
      gfx_x = 250; gfx_y = info_y + 36;
      slider8 <= 3 || slider8 == 7 ? (
        gfx_set(0.6, 0.4, 0.4, 1);
        gfx_printf("Dynamic");
      ) : (
        gfx_set(0.4, 0.4, 0.6, 1);
        gfx_printf("Static");
      );
      
      // Hint text
      gfx_set(0.4, 0.4, 0.4, 1);
      gfx_x = 20; gfx_y = info_y + 54;
      gfx_drawstr("Ctrl+click pan/vol/filter to reset • Shift+click volume to toggle • Alt+click tap for filters");
      
      // Store mouse state for next frame
      last_mouse_x = mouse_x;
      last_mouse_y = mouse_y;
      last_mouse_cap = mouse_cap;
    ); // End of update check
    
    
