desc:Quantum Distance
// One-slider "near->far" effect using Schrodinger equation
// Outlier.ai / ChatGPT - May 2025

slider1:0<0,1,0.001>Distance
slider2:0.20<0,1,0.01>Dry Mix
slider3:1024<256,4096,256>FFT Size

@init
  // Pre-allocate global memory array (large enough for max FFT size)
  gmem[65536]; 
  
  // Constants and initial setup
  max_dt = 0.0025;
  two_pi = 2*$pi;
  
  // Determine FFT size based on slider, ensure power of 2
  var temp_log_val = log(slider3) / log(2); // Calculate log(N)/log(2)
  log2n = floor(temp_log_val);              // Floor to get integer power
  fftlen = 1 << log2n;                      // Calculate 2^power
  hop = fftlen / 2;
  
  // Memory offsets (all in FLOATS, not bytes)
  off_inL   = 0;
  off_inR   = off_inL   + fftlen;          // Input circular buffers (real values)
  off_fftL  = off_inR   + fftlen;          // FFT buffers (complex: 2*fftlen floats)
  off_fftR  = off_fftL  + 2*fftlen;
  off_phase = off_fftR  + 2*fftlen;        // Quantum phase LUT (complex: 2*fftlen floats)
  off_win   = off_phase + 2*fftlen;        // Hann window (real: fftlen floats)
  off_olaL  = off_win   + fftlen;          // Overlap-add buffers (real: fftlen floats)
  off_olaR  = off_olaL  + fftlen;

  // Build Hann window and pre-calculate k^2 values
  i = 0;
  loop(fftlen,
    var win_val = 0.5 - 0.5 * cos(two_pi * i / fftlen);
    gmem[off_win + i] = win_val;
    
    var n_val = (i <= fftlen/2) ? i : (i - fftlen); // Wrap around for negative frequencies
    var k_val = (two_pi * n_val) / fftlen;
    gmem[off_phase + 2*i] = k_val * k_val; // Temporarily store k^2 here
    i += 1;
  );
  
  // Zero out the Overlap-Add buffers (floats * 4 bytes/float)
  memset(gmem + off_olaL, 0, fftlen * 4); // Clear left OLA buffer
  memset(gmem + off_olaR, 0, fftlen * 4); // Clear right OLA buffer
  
  // Initialize runtime state variables
  write_idx = 0; // Current write position in circular input buffer
  hop_ctr = 0;   // Counter for hop samples
  ola_idx = 0;   // Current read position in OLA buffer
  dt_prev = -999.0; // Sentinel for initial phase table calculation (ensure it's different from 0)

  // Initial calculation of the quantum phase table based on current slider1 value
  var current_dt = slider1 * max_dt;
  i = 0;
  loop(fftlen,
    var k2_from_gmem = gmem[off_phase + 2*i]; // Retrieve pre-calculated k^2
    var arg_for_phase = -0.5 * current_dt * k2_from_gmem;
    gmem[off_phase + 2*i] = cos(arg_for_phase);     // Store real part of phase factor
    gmem[off_phase + 2*i + 1] = sin(arg_for_phase); // Store imaginary part of phase factor
    i += 1;
  );

@slider
  // Recalculate phase table if Distance slider has moved
  var new_dt = slider1 * max_dt;
  new_dt != dt_prev ? ( // Only update if dt has truly changed
    dt_prev = new_dt;
    i = 0;
    loop(fftlen,
      var k2_from_gmem = gmem[off_phase + 2*i]; 
      var arg_for_phase = -0.5 * new_dt * k2_from_gmem;
      gmem[off_phase + 2*i] = cos(arg_for_phase);
      gmem[off_phase + 2*i + 1] = sin(arg_for_phase);
      i += 1;
    );
  );
  dry_zone = max(0.0001, slider2); // Ensure dry_zone is never zero to prevent division by zero

@sample
  // 1. Write current input samples into the circular buffers
  gmem[off_inL + write_idx] = spl0;
  gmem[off_inR + write_idx] = spl1;
  
  write_idx += 1;
  write_idx >= fftlen ? write_idx = 0; // Wrap around write index

  // 2. Process a new STFT frame every 'hop' samples
  hop_ctr += 1;
  hop_ctr >= hop ? (
    hop_ctr = 0; // Reset hop counter for the next hop
    
    // 2a. Window the input and copy into FFT buffers
    i = 0;
    loop(fftlen,
      var src_read_idx = write_idx + i;
      src_read_idx >= fftlen ? src_read_idx -= fftlen; // Ensure read index wraps correctly
      
      var current_win_val = gmem[off_win + i];
      
      // Populate FFT buffers (real part from audio, imaginary part is 0)
      gmem[off_fftL + 2*i] = gmem[off_inL + src_read_idx] * current_win_val;
      gmem[off_fftL + 2*i + 1] = 0.0;
      
      gmem[off_fftR + 2*i] = gmem[off_inR + src_read_idx] * current_win_val;
      gmem[off_fftR + 2*i + 1] = 0.0;
      
      i += 1;
    );
    
    // 2b. Perform Forward FFTs
    // Use explicit pointer variables for clarity and robustness
    var fft_ptr_L = gmem + off_fftL;
    var fft_ptr_R = gmem + off_fftR;
    
    fft(fft_ptr_L, fftlen, 0); // Left channel forward FFT
    fft(fft_ptr_R, fftlen, 0); // Right channel forward FFT
    
    // 2c. Apply Split-step Schr√∂dinger evolution (complex multiplication)
    i = 0;
    loop(fftlen,
      var pr_val = gmem[off_phase + 2*i];     // Real part of pre-calculated phase factor
      var pi_val = gmem[off_phase + 2*i + 1]; // Imaginary part of pre-calculated phase factor
      
      // Left channel: current complex value * phase factor
      var re_L_current = gmem[off_fftL + 2*i];
      var im_L_current = gmem[off_fftL + 2*i + 1];
      
      // First half-step of evolution
      var temp_re_L = re_L_current*pr_val - im_L_current*pi_val;
      im_L_current = re_L_current*pi_val + im_L_current*pr_val;
      re_L_current = temp_re_L;
      
      // Second half-step of evolution
      temp_re_L = re_L_current*pr_val - im_L_current*pi_val;
      im_L_current = re_L_current*pi_val + im_L_current*pr_val;
      re_L_current = temp_re_L;
      
      gmem[off_fftL + 2*i] = re_L_current;
      gmem[off_fftL + 2*i + 1] = im_L_current;
      
      // Right channel: current complex value * phase factor
      var re_R_current = gmem[off_fftR + 2*i];
      var im_R_current = gmem[off_fftR + 2*i + 1];
      
      // First half-step of evolution
      var temp_re_R = re_R_current*pr_val - im_R_current*pi_val;
      im_R_current = re_R_current*pi_val + im_R_current*pr_val;
      re_R_current = temp_re_R;
      
      // Second half-step of evolution
      temp_re_R = re_R_current*pr_val - im_R_current*pi_val;
      im_R_current = re_R_current*pi_val + im_R_current*pr_val;
      re_R_current = temp_re_R;
      
      gmem[off_fftR + 2*i] = re_R_current;
      gmem[off_fftR + 2*i + 1] = im_R_current;
      
      i += 1;
    );
    
    // 2d. Perform Inverse FFTs
    // Use explicit pointer variables for clarity and robustness
    var ifft_ptr_L = gmem + off_fftL;
    var ifft_ptr_R = gmem + off_fftR;
    
    fft(ifft_ptr_L, fftlen, 1); // Left channel inverse FFT
    fft(ifft_ptr_R, fftlen, 1); // Right channel inverse FFT
    
    // 2e. Apply output window and perform overlap-add
    var norm_factor = 1.0 / fftlen; // Normalization for IFFT
    i = 0;
    loop(fftlen,
      var current_win_val = gmem[off_win + i];
      gmem[off_olaL + i] += gmem[off_fftL + 2*i] * current_win_val * norm_factor;
      gmem[off_olaR + i] += gmem[off_fftR + 2*i] * current_win_val * norm_factor;
      i += 1;
    );
  );
  
  // 3. Read current sample from the Overlap-Add buffer (this is the wet signal)
  var wetL_sample = gmem[off_olaL + ola_idx];
  var wetR_sample = gmem[off_olaR + ola_idx];
  
  // 4. Crossfade dry and wet signals based on Distance slider
  var mix_amount = (slider1 <= dry_zone) ? (slider1 / dry_zone) : 1.0;
  spl0 = (1.0 - mix_amount) * spl0 + mix_amount * wetL_sample;
  spl1 = (1.0 - mix_amount) * spl1 + mix_amount * wetR_sample;
  
  // 5. Safety limiter to prevent audio clipping
  abs(spl0) > 0.98 ? spl0 = 0.98 * sign(spl0);
  abs(spl1) > 0.98 ? spl1 = 0.98 * sign(spl1);
  
  // 6. Advance OLA read pointer and shift buffer if a 'hop' is completed
  ola_idx += 1;
  ola_idx >= hop ? (
    // Shift OLA buffer left by 'hop' samples (copying floats)
    memcpy(gmem + off_olaL, gmem + off_olaL + hop, (fftlen - hop) * 4); // * 4 bytes/float
    memcpy(gmem + off_olaR, gmem + off_olaR + hop, (fftlen - hop) * 4); // * 4 bytes/float
    
    // Zero out the newly freed 'hop' samples at the end of the buffer (in floats)
    memset(gmem + off_olaL + fftlen - hop, 0, hop * 4); // * 4 bytes/float
    memset(gmem + off_olaR + fftlen - hop, 0, hop * 4); // * 4 bytes/float
    
    ola_idx = 0; // Reset OLA read index for the next hop
  );
